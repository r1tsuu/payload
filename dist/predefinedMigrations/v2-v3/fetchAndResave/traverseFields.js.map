{"version":3,"sources":["../../../../src/predefinedMigrations/v2-v3/fetchAndResave/traverseFields.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { tabHasName } from 'payload/shared'\n\ntype Args = {\n  doc: Record<string, unknown>\n  fields: Field[]\n  locale?: string\n  path: string\n  rows: Record<string, unknown>[]\n}\n\nexport const traverseFields = ({ doc, fields, locale, path, rows }: Args) => {\n  fields.forEach((field) => {\n    switch (field.type) {\n      case 'group': {\n        const newPath = `${path ? `${path}.` : ''}${field.name}`\n        const newDoc = doc?.[field.name]\n\n        if (typeof newDoc === 'object' && newDoc !== null) {\n          if (field.localized) {\n            Object.entries(newDoc).forEach(([locale, localeDoc]) => {\n              return traverseFields({\n                doc: localeDoc,\n                fields: field.fields,\n                locale,\n                path: newPath,\n                rows,\n              })\n            })\n          } else {\n            return traverseFields({\n              doc: newDoc as Record<string, unknown>,\n              fields: field.fields,\n              path: newPath,\n              rows,\n            })\n          }\n        }\n\n        break\n      }\n\n      case 'row':\n      case 'collapsible': {\n        return traverseFields({\n          doc,\n          fields: field.fields,\n          path,\n          rows,\n        })\n      }\n\n      case 'array': {\n        const rowData = doc?.[field.name]\n\n        if (field.localized && typeof rowData === 'object' && rowData !== null) {\n          Object.entries(rowData).forEach(([locale, localeRows]) => {\n            if (Array.isArray(localeRows)) {\n              localeRows.forEach((row, i) => {\n                return traverseFields({\n                  doc: row as Record<string, unknown>,\n                  fields: field.fields,\n                  locale,\n                  path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                  rows,\n                })\n              })\n            }\n          })\n        }\n\n        if (Array.isArray(rowData)) {\n          rowData.forEach((row, i) => {\n            return traverseFields({\n              doc: row as Record<string, unknown>,\n              fields: field.fields,\n              path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n              rows,\n            })\n          })\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const rowData = doc?.[field.name]\n\n        if (field.localized && typeof rowData === 'object' && rowData !== null) {\n          Object.entries(rowData).forEach(([locale, localeRows]) => {\n            if (Array.isArray(localeRows)) {\n              localeRows.forEach((row, i) => {\n                const matchedBlock = field.blocks.find((block) => block.slug === row.blockType)\n\n                if (matchedBlock) {\n                  return traverseFields({\n                    doc: row as Record<string, unknown>,\n                    fields: matchedBlock.fields,\n                    locale,\n                    path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                    rows,\n                  })\n                }\n              })\n            }\n          })\n        }\n\n        if (Array.isArray(rowData)) {\n          rowData.forEach((row, i) => {\n            const matchedBlock = field.blocks.find((block) => block.slug === row.blockType)\n\n            if (matchedBlock) {\n              return traverseFields({\n                doc: row as Record<string, unknown>,\n                fields: matchedBlock.fields,\n                path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                rows,\n              })\n            }\n          })\n        }\n\n        break\n      }\n\n      case 'tabs': {\n        return field.tabs.forEach((tab) => {\n          if (tabHasName(tab)) {\n            const newDoc = doc?.[tab.name]\n            const newPath = `${path ? `${path}.` : ''}${tab.name}`\n\n            if (typeof newDoc === 'object' && newDoc !== null) {\n              if (tab.localized) {\n                Object.entries(newDoc).forEach(([locale, localeDoc]) => {\n                  return traverseFields({\n                    doc: localeDoc,\n                    fields: tab.fields,\n                    locale,\n                    path: newPath,\n                    rows,\n                  })\n                })\n              } else {\n                return traverseFields({\n                  doc: newDoc as Record<string, unknown>,\n                  fields: tab.fields,\n                  path: newPath,\n                  rows,\n                })\n              }\n            }\n          } else {\n            traverseFields({\n              doc,\n              fields: tab.fields,\n              path,\n              rows,\n            })\n          }\n        })\n      }\n\n      case 'relationship':\n      case 'upload': {\n        if (typeof field.relationTo === 'string') {\n          if (field.type === 'upload' || !field.hasMany) {\n            const relationshipPath = `${path ? `${path}.` : ''}${field.name}`\n\n            if (field.localized) {\n              const matchedRelationshipsWithLocales = rows.filter(\n                (row) => row.path === relationshipPath,\n              )\n\n              if (matchedRelationshipsWithLocales.length && !doc[field.name]) {\n                doc[field.name] = {}\n              }\n\n              const newDoc = doc[field.name] as Record<string, unknown>\n\n              matchedRelationshipsWithLocales.forEach((localeRow) => {\n                if (typeof localeRow.locale === 'string') {\n                  const [, id] = Object.entries(localeRow).find(\n                    ([key, val]) =>\n                      val !== null && !['id', 'locale', 'order', 'parent_id', 'path'].includes(key),\n                  )\n\n                  newDoc[localeRow.locale] = id\n                }\n              })\n            } else {\n              const matchedRelationship = rows.find((row) => {\n                const matchesPath = row.path === relationshipPath\n\n                if (locale) return matchesPath && locale === row.locale\n\n                return row.path === relationshipPath\n              })\n\n              if (matchedRelationship) {\n                const [, id] = Object.entries(matchedRelationship).find(\n                  ([key, val]) =>\n                    val !== null && !['id', 'locale', 'order', 'parent_id', 'path'].includes(key),\n                )\n\n                doc[field.name] = id\n              }\n            }\n          }\n        }\n      }\n    }\n  })\n}\n"],"names":["tabHasName","traverseFields","doc","fields","locale","path","rows","forEach","field","type","newPath","name","newDoc","localized","Object","entries","localeDoc","rowData","localeRows","Array","isArray","row","i","matchedBlock","blocks","find","block","slug","blockType","tabs","tab","relationTo","hasMany","relationshipPath","matchedRelationshipsWithLocales","filter","length","localeRow","id","key","val","includes","matchedRelationship","matchesPath"],"mappings":"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"}