{"version":3,"sources":["../../src/bin/generateTypes.ts"],"sourcesContent":["import fs from 'fs'\nimport { compile } from 'json-schema-to-typescript'\n\nimport type { SanitizedConfig } from '../config/types.js'\n\nimport { configToJSONSchema } from '../utilities/configToJSONSchema.js'\nimport Logger from '../utilities/logger.js'\n\nexport async function generateTypes(\n  config: SanitizedConfig,\n  options?: { log: boolean },\n): Promise<void> {\n  const logger = Logger()\n  const outputFile = process.env.PAYLOAD_TS_OUTPUT_PATH || config.typescript.outputFile\n\n  const shouldLog = options?.log ?? true\n\n  if (shouldLog) logger.info('Compiling TS types for Collections and Globals...')\n\n  const jsonSchema = configToJSONSchema(config, config.db.defaultIDType)\n\n  const declare = `declare module 'payload' {\\n  export interface GeneratedTypes extends Config {}\\n}`\n  const declareWithTSIgnoreError = `declare module 'payload' {\\n  // @ts-ignore \\n  export interface GeneratedTypes extends Config {}\\n}`\n\n  let compiled = await compile(jsonSchema, 'Config', {\n    bannerComment:\n      '/* tslint:disable */\\n/* eslint-disable */\\n/**\\n* This file was automatically generated by Payload.\\n* DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\\n* and re-run `payload generate:types` to regenerate this file.\\n*/',\n    style: {\n      singleQuote: true,\n    },\n    // Generates code for $defs that aren't referenced by the schema. Reason:\n    // If a field defines an interfaceName, it should be included in the generated types\n    // even if it's not used by another type. Reason: the user might want to use it in their own code.\n    unreachableDefinitions: true,\n  })\n\n  if (config.typescript.declare !== false) {\n    if (config.typescript.declare?.ignoreTSError) {\n      compiled += `\\n\\n${declareWithTSIgnoreError}`\n    } else {\n      compiled += `\\n\\n${declare}`\n    }\n  }\n\n  // Diff the compiled types against the existing types file\n  try {\n    const existingTypes = fs.readFileSync(outputFile, 'utf-8')\n\n    if (compiled === existingTypes) {\n      return\n    }\n  } catch (_) {\n    // swallow err\n  }\n\n  fs.writeFileSync(outputFile, compiled)\n  if (shouldLog) logger.info(`Types written to ${outputFile}`)\n}\n"],"names":["fs","compile","configToJSONSchema","Logger","generateTypes","config","options","logger","outputFile","process","env","PAYLOAD_TS_OUTPUT_PATH","typescript","shouldLog","log","info","jsonSchema","db","defaultIDType","declare","declareWithTSIgnoreError","compiled","bannerComment","style","singleQuote","unreachableDefinitions","ignoreTSError","existingTypes","readFileSync","_","writeFileSync"],"mappings":"AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,OAAO,QAAQ,4BAA2B;AAInD,SAASC,kBAAkB,QAAQ,qCAAoC;AACvE,OAAOC,YAAY,yBAAwB;AAE3C,OAAO,eAAeC,cACpBC,MAAuB,EACvBC,OAA0B;IAE1B,MAAMC,SAASJ;IACf,MAAMK,aAAaC,QAAQC,GAAG,CAACC,sBAAsB,IAAIN,OAAOO,UAAU,CAACJ,UAAU;IAErF,MAAMK,YAAYP,SAASQ,OAAO;IAElC,IAAID,WAAWN,OAAOQ,IAAI,CAAC;IAE3B,MAAMC,aAAad,mBAAmBG,QAAQA,OAAOY,EAAE,CAACC,aAAa;IAErE,MAAMC,UAAU,CAAC,kFAAkF,CAAC;IACpG,MAAMC,2BAA2B,CAAC,oGAAoG,CAAC;IAEvI,IAAIC,WAAW,MAAMpB,QAAQe,YAAY,UAAU;QACjDM,eACE;QACFC,OAAO;YACLC,aAAa;QACf;QACA,yEAAyE;QACzE,oFAAoF;QACpF,kGAAkG;QAClGC,wBAAwB;IAC1B;IAEA,IAAIpB,OAAOO,UAAU,CAACO,OAAO,KAAK,OAAO;QACvC,IAAId,OAAOO,UAAU,CAACO,OAAO,EAAEO,eAAe;YAC5CL,YAAY,CAAC,IAAI,EAAED,yBAAyB,CAAC;QAC/C,OAAO;YACLC,YAAY,CAAC,IAAI,EAAEF,QAAQ,CAAC;QAC9B;IACF;IAEA,0DAA0D;IAC1D,IAAI;QACF,MAAMQ,gBAAgB3B,GAAG4B,YAAY,CAACpB,YAAY;QAElD,IAAIa,aAAaM,eAAe;YAC9B;QACF;IACF,EAAE,OAAOE,GAAG;IACV,cAAc;IAChB;IAEA7B,GAAG8B,aAAa,CAACtB,YAAYa;IAC7B,IAAIR,WAAWN,OAAOQ,IAAI,CAAC,CAAC,iBAAiB,EAAEP,WAAW,CAAC;AAC7D"}