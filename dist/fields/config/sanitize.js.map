{"version":3,"sources":["../../../src/fields/config/sanitize.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { Field } from './types.js'\n\nimport { MissingEditorProp } from '../../errors/MissingEditorProp.js'\nimport {\n  DuplicateFieldName,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  MissingFieldType,\n} from '../../errors/index.js'\nimport { deepMerge } from '../../utilities/deepMerge.js'\nimport { formatLabels, toWords } from '../../utilities/formatLabels.js'\nimport { baseBlockFields } from '../baseFields/baseBlockFields.js'\nimport { baseIDField } from '../baseFields/baseIDField.js'\nimport { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'\nimport validations from '../validations.js'\nimport { fieldAffectsData, tabHasName } from './types.js'\n\ntype Args = {\n  config: Config\n  existingFieldNames?: Set<string>\n  fields: Field[]\n  /**\n   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.\n   *\n   * @default false\n   */\n  requireFieldLevelRichTextEditor?: boolean\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n\n  /**\n   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.\n   * This validation will be skipped if validRelationships is null.\n   */\n  validRelationships: null | string[]\n}\n\nexport const sanitizeFields = async ({\n  config,\n  existingFieldNames = new Set(),\n  fields,\n  requireFieldLevelRichTextEditor = false,\n  richTextSanitizationPromises,\n  validRelationships,\n}: Args): Promise<Field[]> => {\n  if (!fields) return []\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]\n\n    if (!field.type) throw new MissingFieldType(field)\n\n    // assert that field names do not contain forbidden characters\n    if (fieldAffectsData(field) && field.name.includes('.')) {\n      throw new InvalidFieldName(field, field.name)\n    }\n\n    // Auto-label\n    if (\n      'name' in field &&\n      field.name &&\n      typeof field.label !== 'object' &&\n      typeof field.label !== 'string' &&\n      typeof field.label !== 'function' &&\n      field.label !== false\n    ) {\n      field.label = toWords(field.name)\n    }\n\n    if (\n      field.type === 'checkbox' &&\n      typeof field.defaultValue === 'undefined' &&\n      field.required === true\n    ) {\n      field.defaultValue = false\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (validRelationships) {\n        const relationships = Array.isArray(field.relationTo)\n          ? field.relationTo\n          : [field.relationTo]\n        relationships.forEach((relationship: string) => {\n          if (!validRelationships.includes(relationship)) {\n            throw new InvalidFieldRelationship(field, relationship)\n          }\n        })\n      }\n\n      if (field.type === 'relationship') {\n        if (field.min && !field.minRows) {\n          console.warn(\n            `(payload): The \"min\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"minRows\" instead.`,\n          )\n        }\n        if (field.max && !field.maxRows) {\n          console.warn(\n            `(payload): The \"max\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"maxRows\" instead.`,\n          )\n        }\n        field.minRows = field.minRows || field.min\n        field.maxRows = field.maxRows || field.max\n      }\n    }\n\n    if (field.type === 'blocks' && field.blocks) {\n      field.blocks = field.blocks.map((block) => ({\n        ...block,\n        fields: block.fields.concat(baseBlockFields),\n      }))\n    }\n\n    if (field.type === 'array' && field.fields) {\n      field.fields.push(baseIDField)\n    }\n\n    if ((field.type === 'blocks' || field.type === 'array') && field.label) {\n      field.labels = field.labels || formatLabels(field.name)\n    }\n\n    if (fieldAffectsData(field)) {\n      if (existingFieldNames.has(field.name)) {\n        throw new DuplicateFieldName(field.name)\n      } else if (!['blockName', 'id'].includes(field.name)) {\n        existingFieldNames.add(field.name)\n      }\n\n      if (field.localized && !config.localization) delete field.localized\n\n      if (typeof field.validate === 'undefined') {\n        const defaultValidate = validations[field.type]\n        if (defaultValidate) {\n          field.validate = (val, options) => defaultValidate(val, { ...field, ...options })\n        } else {\n          field.validate = () => true\n        }\n      }\n\n      if (!field.hooks) field.hooks = {}\n      if (!field.access) field.access = {}\n\n      setDefaultBeforeDuplicate(field)\n    }\n\n    if (!field.admin) {\n      field.admin = {}\n    }\n\n    // Make sure that the richText field has an editor\n    if (field.type === 'richText') {\n      const sanitizeRichText = async (_config: SanitizedConfig) => {\n        if (!field.editor) {\n          if (_config.editor && !requireFieldLevelRichTextEditor) {\n            // config.editor should be sanitized at this point\n            field.editor = _config.editor\n          } else {\n            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n          }\n        }\n\n        if (typeof field.editor === 'function') {\n          field.editor = await field.editor({\n            config: _config,\n            isRoot: requireFieldLevelRichTextEditor,\n          })\n        }\n\n        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {\n          config.i18n.translations = deepMerge(config.i18n.translations, field.editor.i18n)\n        }\n      }\n      if (richTextSanitizationPromises) {\n        richTextSanitizationPromises.push(sanitizeRichText)\n      } else {\n        await sanitizeRichText(config as unknown as SanitizedConfig)\n      }\n    }\n\n    if ('fields' in field && field.fields) {\n      field.fields = await sanitizeFields({\n        config,\n        existingFieldNames: fieldAffectsData(field) ? new Set() : existingFieldNames,\n        fields: field.fields,\n        requireFieldLevelRichTextEditor,\n        richTextSanitizationPromises,\n        validRelationships,\n      })\n    }\n\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]\n        if (tabHasName(tab) && typeof tab.label === 'undefined') {\n          tab.label = toWords(tab.name)\n        }\n\n        tab.fields = await sanitizeFields({\n          config,\n          existingFieldNames: tabHasName(tab) ? new Set() : existingFieldNames,\n          fields: tab.fields,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n        field.tabs[j] = tab\n      }\n    }\n\n    if ('blocks' in field && field.blocks) {\n      for (let j = 0; j < field.blocks.length; j++) {\n        const block = field.blocks[j]\n        block.labels = !block.labels ? formatLabels(block.slug) : block.labels\n\n        block.fields = await sanitizeFields({\n          config,\n          existingFieldNames: new Set(),\n          fields: block.fields,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n        field.blocks[j] = block\n      }\n    }\n\n    fields[i] = field\n  }\n\n  return fields\n}\n"],"names":["MissingEditorProp","DuplicateFieldName","InvalidFieldName","InvalidFieldRelationship","MissingFieldType","deepMerge","formatLabels","toWords","baseBlockFields","baseIDField","setDefaultBeforeDuplicate","validations","fieldAffectsData","tabHasName","sanitizeFields","config","existingFieldNames","Set","fields","requireFieldLevelRichTextEditor","richTextSanitizationPromises","validRelationships","i","length","field","type","name","includes","label","defaultValue","required","relationships","Array","isArray","relationTo","forEach","relationship","min","minRows","console","warn","max","maxRows","blocks","map","block","concat","push","labels","has","add","localized","localization","validate","defaultValidate","val","options","hooks","access","admin","sanitizeRichText","_config","editor","isRoot","i18n","Object","keys","translations","j","tabs","tab","slug"],"mappings":"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"}