{"version":3,"sources":["../../../../src/fields/hooks/afterRead/promise.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { PayloadRequestWithData, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport getValueWithDefault from '../../getDefaultValue.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { relationshipPopulationPromise } from './relationshipPopulationPromise.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig | null\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: Record<string, unknown>\n  draft: boolean\n  fallbackLocale: null | string\n  field: Field | TabAsField\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: SanitizedGlobalConfig | null\n  locale: null | string\n  overrideAccess: boolean\n  /**\n   * The parent's path.\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  populationPromises: Promise<void>[]\n  req: PayloadRequestWithData\n  showHiddenFields: boolean\n  siblingDoc: Record<string, unknown>\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Remove hidden fields from response\n// - Flatten locales into requested locale\n// - Sanitize outgoing data (point field, etc.)\n// - Execute field hooks\n// - Execute read access control\n// - Populate relationships\n\nexport const promise = async ({\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  field,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentPath,\n  parentSchemaPath,\n  populationPromises,\n  req,\n  showHiddenFields,\n  siblingDoc,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): Promise<void> => {\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  if (\n    fieldAffectsData(field) &&\n    field.hidden &&\n    typeof siblingDoc[field.name] !== 'undefined' &&\n    !showHiddenFields\n  ) {\n    delete siblingDoc[field.name]\n  }\n\n  const shouldHoistLocalizedValue =\n    flattenLocales &&\n    fieldAffectsData(field) &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null &&\n    field.localized &&\n    locale !== 'all' &&\n    req.payload.config.localization\n\n  if (shouldHoistLocalizedValue) {\n    // replace actual value with localized value before sanitizing\n    // { [locale]: fields } -> fields\n    const value = siblingDoc[field.name][locale]\n\n    let hoistedValue = value\n\n    if (fallbackLocale && fallbackLocale !== locale) {\n      const fallbackValue = siblingDoc[field.name][fallbackLocale]\n      const isNullOrUndefined = typeof value === 'undefined' || value === null\n\n      if (fallbackValue) {\n        switch (field.type) {\n          case 'text':\n          case 'textarea': {\n            if (value === '' || isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n\n          default: {\n            if (isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n        }\n      }\n    }\n\n    siblingDoc[field.name] = hoistedValue\n  }\n\n  // Sanitize outgoing field value\n  switch (field.type) {\n    case 'group': {\n      // Fill groups with empty objects so fields with hooks within groups can populate\n      // themselves virtually as necessary\n      if (typeof siblingDoc[field.name] === 'undefined') {\n        siblingDoc[field.name] = {}\n      }\n\n      break\n    }\n    case 'tabs': {\n      field.tabs.forEach((tab) => {\n        if (\n          tabHasName(tab) &&\n          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)\n        ) {\n          siblingDoc[tab.name] = {}\n        }\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises\n      break\n    }\n\n    case 'point': {\n      const pointDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {\n        siblingDoc[field.name] = pointDoc.coordinates\n      } else {\n        siblingDoc[field.name] = undefined\n      }\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (triggerHooks && field.hooks?.afterRead) {\n      await field.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const shouldRunHookOnAllLocales =\n          field.localized &&\n          (locale === 'all' || !flattenLocales) &&\n          typeof siblingDoc[field.name] === 'object'\n\n        if (shouldRunHookOnAllLocales) {\n          const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n            (async () => {\n              const hookedValue = await currentHook({\n                collection,\n                context,\n                data: doc,\n                field,\n                findMany,\n                global,\n                operation: 'read',\n                originalDoc: doc,\n                overrideAccess,\n                path: fieldPath,\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: siblingDoc,\n                value,\n              })\n\n              if (hookedValue !== undefined) {\n                siblingDoc[field.name][locale] = hookedValue\n              }\n            })(),\n          )\n\n          await Promise.all(hookPromises)\n        } else {\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data: doc,\n            field,\n            findMany,\n            global,\n            operation: 'read',\n            originalDoc: doc,\n            overrideAccess,\n            path: fieldPath,\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingData: siblingDoc,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    let allowDefaultValue = true\n    if (triggerAccessControl && field.access && field.access.read) {\n      const result = overrideAccess\n        ? true\n        : await field.access.read({\n            id: doc.id as number | string,\n            data: doc,\n            doc,\n            req,\n            siblingData: siblingDoc,\n          })\n\n      if (!result) {\n        allowDefaultValue = false\n        delete siblingDoc[field.name]\n      }\n    }\n\n    // Set defaultValue on the field for globals being returned without being first created\n    // or collection documents created prior to having a default\n    if (\n      allowDefaultValue &&\n      typeof siblingDoc[field.name] === 'undefined' &&\n      typeof field.defaultValue !== 'undefined'\n    ) {\n      siblingDoc[field.name] = await getValueWithDefault({\n        defaultValue: field.defaultValue,\n        locale,\n        user: req.user,\n        value: siblingDoc[field.name],\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      populationPromises.push(\n        relationshipPopulationPromise({\n          currentDepth,\n          depth,\n          draft,\n          fallbackLocale,\n          field,\n          locale,\n          overrideAccess,\n          req,\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n  }\n\n  switch (field.type) {\n    case 'group': {\n      let groupDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (typeof siblingDoc[field.name] !== 'object') groupDoc = {}\n\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        showHiddenFields,\n        siblingDoc: groupDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'array': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, i) => {\n          traverseFields({\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            path: [...fieldPath, i],\n            populationPromises,\n            req,\n            schemaPath: fieldSchemaPath,\n            showHiddenFields,\n            siblingDoc: row || {},\n            triggerAccessControl,\n            triggerHooks,\n          })\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, i) => {\n              traverseFields({\n                collection,\n                context,\n                currentDepth,\n                depth,\n                doc,\n                draft,\n                fallbackLocale,\n                fieldPromises,\n                fields: field.fields,\n                findMany,\n                flattenLocales,\n                global,\n                locale,\n                overrideAccess,\n                path: [...fieldPath, i],\n                populationPromises,\n                req,\n                schemaPath: fieldSchemaPath,\n                showHiddenFields,\n                siblingDoc: row || {},\n                triggerAccessControl,\n                triggerHooks,\n              })\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, i) => {\n          const block = field.blocks.find((blockType) => blockType.slug === row.blockType)\n\n          if (block) {\n            traverseFields({\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              fields: block.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              path: [...fieldPath, i],\n              populationPromises,\n              req,\n              schemaPath: fieldSchemaPath,\n              showHiddenFields,\n              siblingDoc: row || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          }\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, i) => {\n              const block = field.blocks.find((blockType) => blockType.slug === row.blockType)\n\n              if (block) {\n                traverseFields({\n                  collection,\n                  context,\n                  currentDepth,\n                  depth,\n                  doc,\n                  draft,\n                  fallbackLocale,\n                  fieldPromises,\n                  fields: block.fields,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  overrideAccess,\n                  path: [...fieldPath, i],\n                  populationPromises,\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  showHiddenFields,\n                  siblingDoc: row || {},\n                  triggerAccessControl,\n                  triggerHooks,\n                })\n              }\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n\n      break\n    }\n\n    case 'row':\n    case 'collapsible': {\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tab': {\n      let tabDoc = siblingDoc\n      if (tabHasName(field)) {\n        tabDoc = siblingDoc[field.name] as Record<string, unknown>\n        if (typeof siblingDoc[field.name] !== 'object') tabDoc = {}\n      }\n\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        showHiddenFields,\n        siblingDoc: tabDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterRead?.length) {\n        await editor.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const shouldRunHookOnAllLocales =\n            field.localized &&\n            (locale === 'all' || !flattenLocales) &&\n            typeof siblingDoc[field.name] === 'object'\n\n          if (shouldRunHookOnAllLocales) {\n            const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n              (async () => {\n                const hookedValue = await currentHook({\n                  collection,\n                  context,\n                  currentDepth,\n                  data: doc,\n                  depth,\n                  draft,\n                  fallbackLocale,\n                  field,\n                  fieldPromises,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  operation: 'read',\n                  originalDoc: doc,\n                  overrideAccess,\n                  path: fieldPath,\n                  populationPromises,\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  showHiddenFields,\n                  siblingData: siblingDoc,\n                  triggerAccessControl,\n                  triggerHooks,\n                  value,\n                })\n\n                if (hookedValue !== undefined) {\n                  siblingDoc[field.name][locale] = hookedValue\n                }\n              })(),\n            )\n\n            await Promise.all(hookPromises)\n          } else {\n            const hookedValue = await currentHook({\n              collection,\n              context,\n              currentDepth,\n              data: doc,\n              depth,\n              draft,\n              fallbackLocale,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              operation: 'read',\n              originalDoc: doc,\n              overrideAccess,\n              path: fieldPath,\n              populationPromises,\n              req,\n              schemaPath: fieldSchemaPath,\n              showHiddenFields,\n              siblingData: siblingDoc,\n              triggerAccessControl,\n              triggerHooks,\n              value: siblingDoc[field.name],\n            })\n\n            if (hookedValue !== undefined) {\n              siblingDoc[field.name] = hookedValue\n            }\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getValueWithDefault","getFieldPaths","relationshipPopulationPromise","traverseFields","promise","collection","context","currentDepth","depth","doc","draft","fallbackLocale","field","fieldPromises","findMany","flattenLocales","global","locale","overrideAccess","parentPath","parentSchemaPath","populationPromises","req","showHiddenFields","siblingDoc","triggerAccessControl","triggerHooks","path","fieldPath","schemaPath","fieldSchemaPath","hidden","name","shouldHoistLocalizedValue","localized","payload","config","localization","value","hoistedValue","fallbackValue","isNullOrUndefined","type","tabs","forEach","tab","editor","Error","pointDoc","Array","isArray","coordinates","length","undefined","hooks","afterRead","reduce","priorHook","currentHook","shouldRunHookOnAllLocales","hookPromises","Object","entries","map","hookedValue","data","operation","originalDoc","siblingData","Promise","all","resolve","allowDefaultValue","access","read","result","id","defaultValue","user","push","groupDoc","fields","rows","row","i","values","localeRows","block","blocks","find","blockType","slug","tabDoc"],"mappings":"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"}