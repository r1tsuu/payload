{"version":3,"sources":["../../../../src/fields/hooks/afterChange/promise.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { PayloadRequestWithData, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig | null\n  context: RequestContext\n  data: Record<string, unknown>\n  doc: Record<string, unknown>\n  field: Field | TabAsField\n  global: SanitizedGlobalConfig | null\n  operation: 'create' | 'update'\n  /**\n   * The parent's path\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  previousDoc: Record<string, unknown>\n  previousSiblingDoc: Record<string, unknown>\n  req: PayloadRequestWithData\n  siblingData: Record<string, unknown>\n  siblingDoc: Record<string, unknown>\n}\n\n// This function is responsible for the following actions, in order:\n// - Execute field hooks\n\nexport const promise = async ({\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  global,\n  operation,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args): Promise<void> => {\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (field.hooks?.afterChange) {\n      await field.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          path: fieldPath,\n          previousDoc,\n          previousSiblingDoc,\n          previousValue: previousDoc[field.name],\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingData,\n          value: siblingDoc[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingDoc[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'group': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: previousDoc[field.name] as Record<string, unknown>,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: (siblingData?.[field.name] as Record<string, unknown>) || {},\n        siblingDoc: siblingDoc[field.name] as Record<string, unknown>,\n      })\n\n      break\n    }\n\n    case 'array': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              path: [...fieldPath, i],\n              previousDoc,\n              previousSiblingDoc: previousDoc?.[field.name]?.[i] || ({} as Record<string, unknown>),\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: siblingData?.[field.name]?.[i] || {},\n              siblingDoc: { ...row } || {},\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const block = field.blocks.find((blockType) => blockType.slug === row.blockType)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                path: [...fieldPath, i],\n                previousDoc,\n                previousSiblingDoc:\n                  previousDoc?.[field.name]?.[i] || ({} as Record<string, unknown>),\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: siblingData?.[field.name]?.[i] || {},\n                siblingDoc: { ...row } || {},\n              }),\n            )\n          }\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'row':\n    case 'collapsible': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabPreviousSiblingDoc = siblingDoc\n\n      if (tabHasName(field)) {\n        tabSiblingData = siblingData[field.name] as Record<string, unknown>\n        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n        tabPreviousSiblingDoc = previousDoc[field.name] as Record<string, unknown>\n      }\n\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: tabPreviousSiblingDoc,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterChange?.length) {\n        await editor.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            operation,\n            originalDoc: doc,\n            path: fieldPath,\n            previousDoc,\n            previousSiblingDoc,\n            previousValue: previousDoc[field.name],\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingData,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getFieldPaths","traverseFields","promise","collection","context","data","doc","field","global","operation","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","path","fieldPath","schemaPath","fieldSchemaPath","hooks","afterChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousValue","name","value","undefined","Promise","resolve","type","fields","rows","Array","isArray","promises","forEach","row","i","push","all","block","blocks","find","blockType","slug","tabSiblingData","tabSiblingDoc","tabPreviousSiblingDoc","tabs","map","tab","editor","Error","length"],"mappings":"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"}