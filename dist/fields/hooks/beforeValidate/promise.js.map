{"version":3,"sources":["../../../../src/fields/hooks/beforeValidate/promise.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { PayloadRequestWithData, RequestContext } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName, valueIsValueWithRelation } from '../../config/types.js'\nimport getValueWithDefault from '../../getDefaultValue.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { cloneDataFromOriginalDoc } from '../beforeChange/cloneDataFromOriginalDoc.js'\nimport { getExistingRowDoc } from '../beforeChange/getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  collection: SanitizedCollectionConfig | null\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  field: Field | TabAsField\n  global: SanitizedGlobalConfig | null\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  parentPath: (number | string)[]\n  parentSchemaPath: string[]\n  req: PayloadRequestWithData\n  siblingData: Record<string, unknown>\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: Record<string, unknown>\n}\n\n// This function is responsible for the following actions, in order:\n// - Sanitize incoming data\n// - Execute field hooks\n// - Execute field access control\n// - Merge original document data into incoming data\n// - Compute default values for undefined fields\n\nexport const promise = async <T>({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  global,\n  operation,\n  overrideAccess,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  if (fieldAffectsData(field)) {\n    if (field.name === 'id') {\n      if (field.type === 'number' && typeof siblingData[field.name] === 'string') {\n        const value = siblingData[field.name] as string\n\n        siblingData[field.name] = parseFloat(value)\n      }\n\n      if (\n        field.type === 'text' &&\n        typeof siblingData[field.name]?.toString === 'function' &&\n        typeof siblingData[field.name] !== 'string'\n      ) {\n        siblingData[field.name] = siblingData[field.name].toString()\n      }\n    }\n\n    // Sanitize incoming data\n    switch (field.type) {\n      case 'number': {\n        if (typeof siblingData[field.name] === 'string') {\n          const value = siblingData[field.name] as string\n          const trimmed = value.trim()\n          siblingData[field.name] = trimmed.length === 0 ? null : parseFloat(trimmed)\n        }\n\n        break\n      }\n\n      case 'point': {\n        if (Array.isArray(siblingData[field.name])) {\n          siblingData[field.name] = (siblingData[field.name] as string[]).map((coordinate, i) => {\n            if (typeof coordinate === 'string') {\n              const value = siblingData[field.name][i] as string\n              const trimmed = value.trim()\n              return trimmed.length === 0 ? null : parseFloat(trimmed)\n            }\n            return coordinate\n          })\n        }\n\n        break\n      }\n\n      case 'checkbox': {\n        if (siblingData[field.name] === 'true') siblingData[field.name] = true\n        if (siblingData[field.name] === 'false') siblingData[field.name] = false\n        if (siblingData[field.name] === '') siblingData[field.name] = false\n\n        break\n      }\n\n      case 'richText': {\n        if (typeof siblingData[field.name] === 'string') {\n          try {\n            const richTextJSON = JSON.parse(siblingData[field.name] as string)\n            siblingData[field.name] = richTextJSON\n          } catch {\n            // Disregard this data as it is not valid.\n            // Will be reported to user by field validation\n          }\n        }\n\n        break\n      }\n\n      case 'relationship':\n      case 'upload': {\n        if (\n          siblingData[field.name] === '' ||\n          siblingData[field.name] === 'none' ||\n          siblingData[field.name] === 'null' ||\n          siblingData[field.name] === null\n        ) {\n          if (field.type === 'relationship' && field.hasMany === true) {\n            siblingData[field.name] = []\n          } else {\n            siblingData[field.name] = null\n          }\n        }\n\n        const value = siblingData[field.name]\n\n        if (Array.isArray(field.relationTo)) {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: { relationTo: string; value: unknown }, i) => {\n              const relatedCollection = req.payload.config.collections.find(\n                (collection) => collection.slug === relatedDoc.relationTo,\n              )\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name][i] = {\n                  ...relatedDoc,\n                  value: parseFloat(relatedDoc.value as string),\n                }\n              }\n            })\n          }\n          if (\n            field.type === 'relationship' &&\n            field.hasMany !== true &&\n            valueIsValueWithRelation(value)\n          ) {\n            const relatedCollection = req.payload.config.collections.find(\n              (collection) => collection.slug === value.relationTo,\n            )\n            const relationshipIDField = relatedCollection.fields.find(\n              (collectionField) =>\n                fieldAffectsData(collectionField) && collectionField.name === 'id',\n            )\n            if (relationshipIDField?.type === 'number') {\n              siblingData[field.name] = { ...value, value: parseFloat(value.value as string) }\n            }\n          }\n        } else {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: unknown, i) => {\n              const relatedCollection = req.payload.config.collections.find(\n                (collection) => collection.slug === field.relationTo,\n              )\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name][i] = parseFloat(relatedDoc as string)\n              }\n            })\n          }\n          if (field.type === 'relationship' && field.hasMany !== true && value) {\n            const relatedCollection = req.payload.config.collections.find(\n              (collection) => collection.slug === field.relationTo,\n            )\n            const relationshipIDField = relatedCollection.fields.find(\n              (collectionField) =>\n                fieldAffectsData(collectionField) && collectionField.name === 'id',\n            )\n            if (relationshipIDField?.type === 'number') {\n              siblingData[field.name] = parseFloat(value as string)\n            }\n          }\n        }\n        break\n      }\n\n      case 'array':\n      case 'blocks': {\n        // Handle cases of arrays being intentionally set to 0\n        if (siblingData[field.name] === '0' || siblingData[field.name] === 0) {\n          siblingData[field.name] = []\n        }\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeValidate) {\n      await field.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          overrideAccess,\n          path: fieldPath,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingData[field.name],\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingData,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    if (field.access && field.access[operation]) {\n      const result = overrideAccess\n        ? true\n        : await field.access[operation]({ id, data, doc, req, siblingData })\n\n      if (!result) {\n        delete siblingData[field.name]\n      }\n    }\n\n    if (typeof siblingData[field.name] === 'undefined') {\n      // If no incoming data, but existing document data is found, merge it in\n      if (typeof siblingDoc[field.name] !== 'undefined') {\n        siblingData[field.name] = cloneDataFromOriginalDoc(siblingDoc[field.name])\n\n        // Otherwise compute default value\n      } else if (typeof field.defaultValue !== 'undefined') {\n        siblingData[field.name] = await getValueWithDefault({\n          defaultValue: field.defaultValue,\n          locale: req.locale,\n          user: req.user,\n          value: siblingData[field.name],\n        })\n      }\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') siblingData[field.name] = {}\n      if (typeof siblingDoc[field.name] !== 'object') siblingDoc[field.name] = {}\n\n      const groupData = siblingData[field.name] as Record<string, unknown>\n      const groupDoc = siblingDoc[field.name] as Record<string, unknown>\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: groupData,\n        siblingDoc: groupDoc,\n      })\n\n      break\n    }\n\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              id,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              overrideAccess,\n              path: [...fieldPath, i],\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: row,\n              siblingDoc: getExistingRowDoc(row, siblingDoc[field.name]),\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const rowSiblingDoc = getExistingRowDoc(row, siblingDoc[field.name])\n          const blockTypeToMatch = row.blockType || rowSiblingDoc.blockType\n          const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n          if (block) {\n            row.blockType = blockTypeToMatch\n\n            promises.push(\n              traverseFields({\n                id,\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                overrideAccess,\n                path: [...fieldPath, i],\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: row,\n                siblingDoc: rowSiblingDoc,\n              }),\n            )\n          }\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'row':\n    case 'collapsible': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData\n      let tabSiblingDoc\n      if (tabHasName(field)) {\n        if (typeof siblingData[field.name] !== 'object') siblingData[field.name] = {}\n        if (typeof siblingDoc[field.name] !== 'object') siblingDoc[field.name] = {}\n\n        tabSiblingData = siblingData[field.name] as Record<string, unknown>\n        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n      } else {\n        tabSiblingData = siblingData\n        tabSiblingDoc = siblingDoc\n      }\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeValidate?.length) {\n        await editor.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            operation,\n            originalDoc: doc,\n            overrideAccess,\n            path: fieldPath,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingData[field.name],\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingData,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","valueIsValueWithRelation","getValueWithDefault","getFieldPaths","cloneDataFromOriginalDoc","getExistingRowDoc","traverseFields","promise","id","collection","context","data","doc","field","global","operation","overrideAccess","parentPath","parentSchemaPath","req","siblingData","siblingDoc","path","fieldPath","schemaPath","fieldSchemaPath","name","type","value","parseFloat","toString","trimmed","trim","length","Array","isArray","map","coordinate","i","richTextJSON","JSON","parse","hasMany","relationTo","forEach","relatedDoc","relatedCollection","payload","config","collections","find","slug","relationshipIDField","fields","collectionField","hooks","beforeValidate","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","undefined","Promise","resolve","access","result","defaultValue","locale","user","groupData","groupDoc","rows","promises","row","push","all","rowSiblingDoc","blockTypeToMatch","blockType","block","blocks","tabSiblingData","tabSiblingDoc","tabs","tab","editor","Error"],"mappings":"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"}