{"version":3,"sources":["../../../../src/fields/hooks/beforeChange/promise.ts"],"sourcesContent":["import merge from 'deepmerge'\n\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { Operation, PayloadRequestWithData, RequestContext } from '../../../types/index.js'\nimport type { Field, FieldHookArgs, TabAsField, ValidateOptions } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { beforeDuplicate } from './beforeDuplicate.js'\nimport { getExistingRowDoc } from './getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig | null\n  context: RequestContext\n  data: Record<string, unknown>\n  doc: Record<string, unknown>\n  docWithLocales: Record<string, unknown>\n  duplicate: boolean\n  errors: { field: string; message: string }[]\n  field: Field | TabAsField\n  global: SanitizedGlobalConfig | null\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  /**\n   * The parent's path.\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  req: PayloadRequestWithData\n  siblingData: Record<string, unknown>\n  siblingDoc: Record<string, unknown>\n  siblingDocWithLocales?: Record<string, unknown>\n  skipValidation: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Run condition\n// - Execute field hooks\n// - Validate data\n// - Transform data for storage\n// - beforeDuplicate hooks (if duplicate)\n// - Unflatten locales\n\nexport const promise = async ({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  duplicate,\n  errors,\n  field,\n  global,\n  mergeLocaleActions,\n  operation,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  skipValidation,\n}: Args): Promise<void> => {\n  const passesCondition = field.admin?.condition\n    ? Boolean(field.admin.condition(data, siblingData, { user: req.user }))\n    : true\n  let skipValidationFromHere = skipValidation || !passesCondition\n  const { localization } = req.payload.config\n  const defaultLocale = localization ? localization?.defaultLocale : 'en'\n  const operationLocale = req.locale || defaultLocale\n\n  const { path: fieldPath, schemaPath: fieldSchemaPath } = getFieldPaths({\n    field,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  if (fieldAffectsData(field)) {\n    // skip validation if the field is localized and the incoming data is null\n    if (field.localized && operationLocale !== defaultLocale) {\n      if (['array', 'blocks'].includes(field.type) && siblingData[field.name] === null) {\n        skipValidationFromHere = true\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeChange) {\n      await field.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          path: fieldPath,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: parentSchemaPath,\n          siblingData,\n          siblingDocWithLocales,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Validate\n    if (!skipValidationFromHere && field.validate) {\n      const valueToValidate = siblingData[field.name]\n      let jsonError: object\n\n      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {\n        try {\n          JSON.parse(siblingData[field.name] as string)\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      const validationResult = await field.validate(valueToValidate, {\n        ...field,\n        id,\n        data: merge(doc, data, { arrayMerge: (_, source) => source }),\n        jsonError,\n        operation,\n        preferences: { fields: {} },\n        req,\n        siblingData: merge(siblingDoc, siblingData, { arrayMerge: (_, source) => source }),\n      } as ValidateOptions<any, any, { jsonError: object }>)\n\n      if (typeof validationResult === 'string') {\n        errors.push({\n          field: fieldPath.join('.'),\n          message: validationResult,\n        })\n      }\n    }\n\n    const beforeDuplicateArgs: FieldHookArgs = {\n      collection,\n      context,\n      data,\n      field,\n      global: undefined,\n      path: fieldPath,\n      previousSiblingDoc: siblingDoc,\n      previousValue: siblingDoc[field.name],\n      req,\n      schemaPath: parentSchemaPath,\n      siblingData,\n      siblingDocWithLocales,\n      value: siblingData[field.name],\n    }\n\n    // Push merge locale action if applicable\n    if (localization && field.localized) {\n      mergeLocaleActions.push(async () => {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<Record<string, unknown>>, locale) => {\n            const localizedValues = await localizedValuesPromise\n            let fieldValue =\n              locale === req.locale\n                ? siblingData[field.name]\n                : siblingDocWithLocales?.[field.name]?.[locale]\n\n            if (duplicate && field.hooks?.beforeDuplicate?.length) {\n              beforeDuplicateArgs.value = fieldValue\n              fieldValue = await beforeDuplicate(beforeDuplicateArgs)\n            }\n\n            // const result = await localizedValues\n            // update locale value if it's not undefined\n            if (typeof fieldValue !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: fieldValue,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        // If there are locales with data, set the data\n        if (Object.keys(localeData).length > 0) {\n          siblingData[field.name] = localeData\n        }\n      })\n    } else if (duplicate && field.hooks?.beforeDuplicate?.length) {\n      mergeLocaleActions.push(async () => {\n        siblingData[field.name] = await beforeDuplicate(beforeDuplicateArgs)\n      })\n    }\n  }\n\n  switch (field.type) {\n    case 'point': {\n      // Transform point data for storage\n      if (\n        Array.isArray(siblingData[field.name]) &&\n        siblingData[field.name][0] !== null &&\n        siblingData[field.name][1] !== null\n      ) {\n        siblingData[field.name] = {\n          type: 'Point',\n          coordinates: [\n            parseFloat(siblingData[field.name][0]),\n            parseFloat(siblingData[field.name][1]),\n          ],\n        }\n      }\n\n      break\n    }\n\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') siblingData[field.name] = {}\n      if (typeof siblingDoc[field.name] !== 'object') siblingDoc[field.name] = {}\n      if (typeof siblingDocWithLocales[field.name] !== 'object')\n        siblingDocWithLocales[field.name] = {}\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        duplicate,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData[field.name] as Record<string, unknown>,\n        siblingDoc: siblingDoc[field.name] as Record<string, unknown>,\n        siblingDocWithLocales: siblingDocWithLocales[field.name] as Record<string, unknown>,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              id,\n              collection,\n              context,\n              data,\n              doc,\n              docWithLocales,\n              duplicate,\n              errors,\n              fields: field.fields,\n              global,\n              mergeLocaleActions,\n              operation,\n              path: [...fieldPath, i],\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: row,\n              siblingDoc: getExistingRowDoc(row, siblingDoc[field.name]),\n              siblingDocWithLocales: getExistingRowDoc(row, siblingDocWithLocales[field.name]),\n              skipValidation: skipValidationFromHere,\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const rowSiblingDoc = getExistingRowDoc(row, siblingDoc[field.name])\n          const rowSiblingDocWithLocales = getExistingRowDoc(row, siblingDocWithLocales[field.name])\n\n          const blockTypeToMatch = row.blockType || rowSiblingDoc.blockType\n          const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                id,\n                collection,\n                context,\n                data,\n                doc,\n                docWithLocales,\n                duplicate,\n                errors,\n                fields: block.fields,\n                global,\n                mergeLocaleActions,\n                operation,\n                path: [...fieldPath, i],\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: row,\n                siblingDoc: rowSiblingDoc,\n                siblingDocWithLocales: rowSiblingDocWithLocales,\n                skipValidation: skipValidationFromHere,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'row':\n    case 'collapsible': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        duplicate,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabSiblingDocWithLocales = siblingDocWithLocales\n\n      if (tabHasName(field)) {\n        if (typeof siblingData[field.name] !== 'object') siblingData[field.name] = {}\n        if (typeof siblingDoc[field.name] !== 'object') siblingDoc[field.name] = {}\n        if (typeof siblingDocWithLocales[field.name] !== 'object')\n          siblingDocWithLocales[field.name] = {}\n\n        tabSiblingData = siblingData[field.name] as Record<string, unknown>\n        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n        tabSiblingDocWithLocales = siblingDocWithLocales[field.name] as Record<string, unknown>\n      }\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        duplicate,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n        siblingDocWithLocales: tabSiblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        duplicate,\n        errors,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeChange?.length) {\n        await editor.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            docWithLocales,\n            duplicate,\n            errors,\n            field,\n            global,\n            mergeLocaleActions,\n            operation,\n            originalDoc: doc,\n            path: fieldPath,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name],\n            req,\n            schemaPath: parentSchemaPath,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["merge","MissingEditorProp","fieldAffectsData","tabHasName","getFieldPaths","beforeDuplicate","getExistingRowDoc","traverseFields","promise","id","collection","context","data","doc","docWithLocales","duplicate","errors","field","global","mergeLocaleActions","operation","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","skipValidation","passesCondition","admin","condition","Boolean","user","skipValidationFromHere","localization","payload","config","defaultLocale","operationLocale","locale","path","fieldPath","schemaPath","fieldSchemaPath","localized","includes","type","name","hooks","beforeChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","value","undefined","Promise","resolve","validate","valueToValidate","jsonError","JSON","parse","e","validationResult","arrayMerge","_","source","preferences","fields","push","join","message","beforeDuplicateArgs","localeData","localeCodes","localizedValuesPromise","localizedValues","fieldValue","length","Object","keys","Array","isArray","coordinates","parseFloat","rows","promises","forEach","row","i","all","rowSiblingDoc","rowSiblingDocWithLocales","blockTypeToMatch","blockType","block","blocks","find","slug","tabSiblingData","tabSiblingDoc","tabSiblingDocWithLocales","tabs","map","tab","editor","Error"],"mappings":"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"}