{"version":3,"sources":["../../../src/transform/read/traverseFields.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { Field, TabAsField } from 'payload'\nimport type { SanitizedConfig } from 'payload'\n\nimport { fieldAffectsData } from 'payload/shared'\n\nimport type { PostgresAdapter } from '../../types.js'\nimport type { BlocksMap } from '../../utilities/createBlocksMap.js'\n\nimport { transformHasManyNumber } from './hasManyNumber.js'\nimport { transformHasManyText } from './hasManyText.js'\nimport { transformRelationship } from './relationship.js'\n\ntype TraverseFieldsArgs = {\n  /**\n   * The DB adapter\n   */\n  adapter: PostgresAdapter\n  /**\n   * Pre-formatted blocks map\n   */\n  blocks: BlocksMap\n  /**\n   * The full Payload config\n   */\n  config: SanitizedConfig\n  /**\n   * The data reference to be mutated within this recursive function\n   */\n  dataRef: Record<string, unknown>\n  /**\n   * Data that needs to be removed from the result after all fields have populated\n   */\n  deletions: (() => void)[]\n  /**\n   * Column prefix can be built up by group and named tab fields\n   */\n  fieldPrefix: string\n  /**\n   * An array of Payload fields to traverse\n   */\n  fields: (Field | TabAsField)[]\n  /**\n   * All hasMany number fields, as returned by Drizzle, keyed on an object by field path\n   */\n  numbers: Record<string, Record<string, unknown>[]>\n  /**\n   * The current field path (in dot notation), used to merge in relationships\n   */\n  path: string\n  /**\n   * All related documents, as returned by Drizzle, keyed on an object by field path\n   */\n  relationships: Record<string, Record<string, unknown>[]>\n  /**\n   * Data structure representing the nearest table from db\n   */\n  table: Record<string, unknown>\n  /**\n   * All hasMany text fields, as returned by Drizzle, keyed on an object by field path\n   */\n  texts: Record<string, Record<string, unknown>[]>\n}\n\n// Traverse fields recursively, transforming data\n// for each field type into required Payload shape\nexport const traverseFields = <T extends Record<string, unknown>>({\n  adapter,\n  blocks,\n  config,\n  dataRef,\n  deletions,\n  fieldPrefix,\n  fields,\n  numbers,\n  path,\n  relationships,\n  table,\n  texts,\n}: TraverseFieldsArgs): T => {\n  const sanitizedPath = path ? `${path}.` : path\n\n  const formatted = fields.reduce((result, field) => {\n    if (field.type === 'tabs') {\n      traverseFields({\n        adapter,\n        blocks,\n        config,\n        dataRef,\n        deletions,\n        fieldPrefix,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        numbers,\n        path,\n        relationships,\n        table,\n        texts,\n      })\n    }\n\n    if (\n      field.type === 'collapsible' ||\n      field.type === 'row' ||\n      (field.type === 'tab' && !('name' in field))\n    ) {\n      traverseFields({\n        adapter,\n        blocks,\n        config,\n        dataRef,\n        deletions,\n        fieldPrefix,\n        fields: field.fields,\n        numbers,\n        path,\n        relationships,\n        table,\n        texts,\n      })\n    }\n\n    if (fieldAffectsData(field)) {\n      if ('dbStore' in field && !field.dbStore) return result\n\n      const fieldName = `${fieldPrefix || ''}${field.name}`\n      const fieldData = table[fieldName]\n      const localizedFieldData = {}\n      const valuesToTransform: {\n        ref: Record<string, unknown>\n        table: Record<string, unknown>\n      }[] = []\n\n      if (fieldPrefix) {\n        deletions.push(() => delete table[fieldName])\n      }\n\n      if ('dbJsonColumn' in field && field.dbJsonColumn) {\n        result[field.name] = table[`${fieldPrefix || ''}${field.name}`]\n        return result\n      }\n\n      if (field.type === 'array') {\n        if (Array.isArray(fieldData)) {\n          if (field.localized) {\n            result[field.name] = fieldData.reduce((arrayResult, row) => {\n              if (typeof row._locale === 'string') {\n                if (!arrayResult[row._locale]) arrayResult[row._locale] = []\n                const locale = row._locale\n                const data = {}\n                delete row._locale\n                if (row._uuid) {\n                  row.id = row._uuid\n                  delete row._uuid\n                }\n\n                const rowResult = traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: data,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: field.fields,\n                  numbers,\n                  path: `${sanitizedPath}${field.name}.${row._order - 1}`,\n                  relationships,\n                  table: row,\n                  texts,\n                })\n\n                if ('_order' in rowResult) {\n                  delete rowResult._order\n                }\n\n                arrayResult[locale].push(rowResult)\n              }\n\n              return arrayResult\n            }, {})\n          } else {\n            result[field.name] = fieldData.map((row, i) => {\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n\n              if ('_order' in row) {\n                delete row._order\n              }\n\n              return traverseFields<T>({\n                adapter,\n                blocks,\n                config,\n                dataRef: row,\n                deletions,\n                fieldPrefix: '',\n                fields: field.fields,\n                numbers,\n                path: `${sanitizedPath}${field.name}.${i}`,\n                relationships,\n                table: row,\n                texts,\n              })\n            })\n          }\n        }\n\n        return result\n      }\n\n      if (field.type === 'blocks') {\n        const blockFieldPath = `${sanitizedPath}${field.name}`\n\n        if (Array.isArray(blocks[blockFieldPath])) {\n          if (field.localized) {\n            result[field.name] = {}\n\n            blocks[blockFieldPath].forEach((row) => {\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n              if (typeof row._locale === 'string') {\n                if (!result[field.name][row._locale]) result[field.name][row._locale] = []\n                result[field.name][row._locale].push(row)\n                delete row._locale\n              }\n            })\n\n            Object.entries(result[field.name]).forEach(([locale, localizedBlocks]) => {\n              result[field.name][locale] = localizedBlocks.map((row) => {\n                const block = field.blocks.find(({ slug }) => slug === row.blockType)\n\n                if (block) {\n                  const blockResult = traverseFields<T>({\n                    adapter,\n                    blocks,\n                    config,\n                    dataRef: row,\n                    deletions,\n                    fieldPrefix: '',\n                    fields: block.fields,\n                    numbers,\n                    path: `${blockFieldPath}.${row._order - 1}`,\n                    relationships,\n                    table: row,\n                    texts,\n                  })\n\n                  delete blockResult._order\n                  return blockResult\n                }\n\n                return {}\n              })\n            })\n          } else {\n            result[field.name] = blocks[blockFieldPath].map((row, i) => {\n              delete row._order\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n              const block = field.blocks.find(({ slug }) => slug === row.blockType)\n\n              if (block) {\n                return traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: block.fields,\n                  numbers,\n                  path: `${blockFieldPath}.${i}`,\n                  relationships,\n                  table: row,\n                  texts,\n                })\n              }\n\n              return {}\n            })\n          }\n        }\n\n        return result\n      }\n\n      if (field.type === 'relationship' || field.type === 'upload') {\n        if (typeof field.relationTo === 'string' && !('hasMany' in field && field.hasMany)) {\n          if (\n            field.localized &&\n            config.localization &&\n            config.localization.locales &&\n            Array.isArray(table?._locales)\n          ) {\n            table._locales.forEach((localeRow) => {\n              result[field.name] = { [localeRow._locale]: localeRow[fieldName] }\n            })\n          } else {\n            valuesToTransform.push({ ref: result, table })\n          }\n        } else {\n          const relationPathMatch = relationships[`${sanitizedPath}${field.name}`]\n          if (!relationPathMatch) {\n            if ('hasMany' in field && field.hasMany) {\n              if (field.localized && config.localization && config.localization.locales) {\n                result[field.name] = {\n                  [config.localization.defaultLocale]: [],\n                }\n              } else {\n                result[field.name] = []\n              }\n            }\n\n            return result\n          }\n\n          if (field.localized) {\n            result[field.name] = {}\n            const relationsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n            relationPathMatch.forEach((row) => {\n              if (typeof row.locale === 'string') {\n                if (!relationsByLocale[row.locale]) relationsByLocale[row.locale] = []\n                relationsByLocale[row.locale].push(row)\n              }\n            })\n\n            Object.entries(relationsByLocale).forEach(([locale, relations]) => {\n              transformRelationship({\n                field,\n                locale,\n                ref: result,\n                relations,\n              })\n            })\n          } else {\n            transformRelationship({\n              field,\n              ref: result,\n              relations: relationPathMatch,\n            })\n          }\n          return result\n        }\n      }\n\n      if (field.type === 'text' && field?.hasMany) {\n        const textPathMatch = texts[`${sanitizedPath}${field.name}`]\n        if (!textPathMatch) return result\n\n        if (field.localized) {\n          result[field.name] = {}\n          const textsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n          textPathMatch.forEach((row) => {\n            if (typeof row.locale === 'string') {\n              if (!textsByLocale[row.locale]) textsByLocale[row.locale] = []\n              textsByLocale[row.locale].push(row)\n            }\n          })\n\n          Object.entries(textsByLocale).forEach(([locale, texts]) => {\n            transformHasManyText({\n              field,\n              locale,\n              ref: result,\n              textRows: texts,\n            })\n          })\n        } else {\n          transformHasManyText({\n            field,\n            ref: result,\n            textRows: textPathMatch,\n          })\n        }\n\n        return result\n      }\n\n      if (field.type === 'number' && field.hasMany) {\n        const numberPathMatch = numbers[`${sanitizedPath}${field.name}`]\n        if (!numberPathMatch) return result\n\n        if (field.localized) {\n          result[field.name] = {}\n          const numbersByLocale: Record<string, Record<string, unknown>[]> = {}\n\n          numberPathMatch.forEach((row) => {\n            if (typeof row.locale === 'string') {\n              if (!numbersByLocale[row.locale]) numbersByLocale[row.locale] = []\n              numbersByLocale[row.locale].push(row)\n            }\n          })\n\n          Object.entries(numbersByLocale).forEach(([locale, numbers]) => {\n            transformHasManyNumber({\n              field,\n              locale,\n              numberRows: numbers,\n              ref: result,\n            })\n          })\n        } else {\n          transformHasManyNumber({\n            field,\n            numberRows: numberPathMatch,\n            ref: result,\n          })\n        }\n\n        return result\n      }\n\n      if (field.type === 'select' && field.hasMany) {\n        if (Array.isArray(fieldData)) {\n          if (field.localized) {\n            result[field.name] = fieldData.reduce((selectResult, row) => {\n              if (typeof row.locale === 'string') {\n                if (!selectResult[row.locale]) selectResult[row.locale] = []\n                selectResult[row.locale].push(row.value)\n              }\n\n              return selectResult\n            }, {})\n          } else {\n            result[field.name] = fieldData.map(({ value }) => value)\n          }\n        }\n        return result\n      }\n\n      if (field.localized && Array.isArray(table._locales)) {\n        table._locales.forEach((localeRow) => {\n          valuesToTransform.push({ ref: localizedFieldData, table: localeRow })\n        })\n      } else {\n        valuesToTransform.push({ ref: result, table })\n      }\n\n      valuesToTransform.forEach(({ ref, table }) => {\n        const fieldData = table[`${fieldPrefix || ''}${field.name}`]\n        const locale = table?._locale\n        let val = fieldData\n\n        switch (field.type) {\n          case 'tab':\n          case 'group': {\n            const groupFieldPrefix = `${fieldPrefix || ''}${field.name}_`\n\n            if (field.localized) {\n              if (typeof locale === 'string' && !ref[locale]) {\n                ref[locale] = {}\n                delete table._locale\n              }\n\n              Object.entries(ref).forEach(([groupLocale, groupLocaleData]) => {\n                ref[groupLocale] = traverseFields<Record<string, unknown>>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: groupLocaleData as Record<string, unknown>,\n                  deletions,\n                  fieldPrefix: groupFieldPrefix,\n                  fields: field.fields,\n                  numbers,\n                  path: `${sanitizedPath}${field.name}`,\n                  relationships,\n                  table,\n                  texts,\n                })\n              })\n              if ('_order' in ref) {\n                delete ref._order\n              }\n            } else {\n              const groupData = {}\n\n              ref[field.name] = traverseFields<Record<string, unknown>>({\n                adapter,\n                blocks,\n                config,\n                dataRef: groupData as Record<string, unknown>,\n                deletions,\n                fieldPrefix: groupFieldPrefix,\n                fields: field.fields,\n                numbers,\n                path: `${sanitizedPath}${field.name}`,\n                relationships,\n                table,\n                texts,\n              })\n              if ('_order' in ref) {\n                delete ref._order\n              }\n            }\n\n            return\n          }\n\n          case 'text': {\n            if (typeof fieldData === 'string') {\n              val = String(fieldData)\n            }\n\n            break\n          }\n\n          case 'number': {\n            if (typeof fieldData === 'string') {\n              val = Number.parseFloat(fieldData)\n            }\n\n            break\n          }\n\n          case 'date': {\n            if (typeof fieldData === 'string') {\n              val = new Date(fieldData).toISOString()\n            }\n\n            break\n          }\n\n          case 'relationship':\n          case 'upload': {\n            if (\n              val &&\n              typeof field.relationTo === 'string' &&\n              adapter.payload.collections[field.relationTo].customIDType === 'number'\n            ) {\n              val = Number(val)\n            }\n\n            break\n          }\n\n          default: {\n            break\n          }\n        }\n        if (typeof locale === 'string') {\n          ref[locale] = val\n        } else {\n          result[field.name] = val\n        }\n      })\n\n      if (Object.keys(localizedFieldData).length > 0) {\n        result[field.name] = localizedFieldData\n      }\n\n      return result\n    }\n\n    return result\n  }, dataRef)\n\n  if (Array.isArray(table._locales)) {\n    deletions.push(() => delete table._locales)\n  }\n\n  return formatted as T\n}\n"],"names":["fieldAffectsData","transformHasManyNumber","transformHasManyText","transformRelationship","traverseFields","adapter","blocks","config","dataRef","deletions","fieldPrefix","fields","numbers","path","relationships","table","texts","sanitizedPath","formatted","reduce","result","field","type","tabs","map","tab","dbStore","fieldName","name","fieldData","localizedFieldData","valuesToTransform","push","dbJsonColumn","Array","isArray","localized","arrayResult","row","_locale","locale","data","_uuid","id","rowResult","_order","i","blockFieldPath","forEach","Object","entries","localizedBlocks","block","find","slug","blockType","blockResult","relationTo","hasMany","localization","locales","_locales","localeRow","ref","relationPathMatch","defaultLocale","relationsByLocale","relations","textPathMatch","textsByLocale","textRows","numberPathMatch","numbersByLocale","numberRows","selectResult","value","val","groupFieldPrefix","groupLocale","groupLocaleData","groupData","String","Number","parseFloat","Date","toISOString","payload","collections","customIDType","keys","length"],"mappings":"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"}