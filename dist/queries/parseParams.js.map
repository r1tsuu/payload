{"version":3,"sources":["../../src/queries/parseParams.ts"],"sourcesContent":["/* eslint-disable no-await-in-loop */\nimport type { SQL } from 'drizzle-orm'\nimport type { Field, Operator, Where } from 'payload'\n\nimport { and, ilike, isNotNull, isNull, ne, notInArray, or, sql } from 'drizzle-orm'\nimport { QueryError } from 'payload'\nimport { validOperators } from 'payload/shared'\n\nimport type { GenericColumn, PostgresAdapter } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { buildAndOrConditions } from './buildAndOrConditions.js'\nimport { convertPathToJSONTraversal } from './createJSONQuery/convertPathToJSONTraversal.js'\nimport { createJSONQuery } from './createJSONQuery/index.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\nimport { operatorMap } from './operatorMap.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\ntype Args = {\n  adapter: PostgresAdapter\n  fields: Field[]\n  joins: BuildQueryJoinAliases\n  locale: string\n  selectFields: Record<string, GenericColumn>\n  tableName: string\n  where: Where\n}\n\nexport async function parseParams({\n  adapter,\n  fields,\n  joins,\n  locale,\n  selectFields,\n  tableName,\n  where,\n}: Args): Promise<SQL> {\n  let result: SQL\n  const constraints: SQL[] = []\n\n  if (typeof where === 'object' && Object.keys(where).length > 0) {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    for (const relationOrPath of Object.keys(where)) {\n      if (relationOrPath) {\n        const condition = where[relationOrPath]\n        let conditionOperator: 'and' | 'or'\n        if (relationOrPath.toLowerCase() === 'and') {\n          conditionOperator = 'and'\n        } else if (relationOrPath.toLowerCase() === 'or') {\n          conditionOperator = 'or'\n        }\n        if (Array.isArray(condition)) {\n          const builtConditions = await buildAndOrConditions({\n            adapter,\n            fields,\n            joins,\n            locale,\n            selectFields,\n            tableName,\n            where: condition,\n          })\n          if (builtConditions.length > 0) {\n            result = operatorMap[conditionOperator](...builtConditions)\n          }\n        } else {\n          // It's a path - and there can be multiple comparisons on a single path.\n          // For example - title like 'test' and title not equal to 'tester'\n          // So we need to loop on keys again here to handle each operator independently\n          const pathOperators = where[relationOrPath]\n          if (typeof pathOperators === 'object') {\n            for (let operator of Object.keys(pathOperators)) {\n              if (validOperators.includes(operator as Operator)) {\n                const val = where[relationOrPath][operator]\n                const {\n                  columnName,\n                  constraints: queryConstraints,\n                  field,\n                  getNotNullColumnByValue,\n                  pathSegments,\n                  rawColumn,\n                  table,\n                } = getTableColumnFromPath({\n                  adapter,\n                  collectionPath: relationOrPath,\n                  fields,\n                  joins,\n                  locale,\n                  pathSegments: relationOrPath.replace(/__/g, '.').split('.'),\n                  selectFields,\n                  tableName,\n                  value: val,\n                })\n\n                queryConstraints.forEach(({ columnName: col, table: constraintTable, value }) => {\n                  if (typeof value === 'string' && value.indexOf('%') > -1) {\n                    constraints.push(operatorMap.like(constraintTable[col], value))\n                  } else {\n                    constraints.push(operatorMap.equals(constraintTable[col], value))\n                  }\n                })\n\n                if (\n                  ['json', 'richText'].includes(field.type) &&\n                  Array.isArray(pathSegments) &&\n                  pathSegments.length > 1\n                ) {\n                  const segments = pathSegments.slice(1)\n                  segments.unshift(table[columnName].name)\n\n                  if (field.type === 'richText') {\n                    const jsonQuery = createJSONQuery({\n                      operator,\n                      pathSegments: segments,\n                      treatAsArray: ['children'],\n                      treatRootAsArray: true,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(jsonQuery))\n                    break\n                  }\n\n                  const jsonQuery = convertPathToJSONTraversal(pathSegments)\n                  const operatorKeys = {\n                    contains: { operator: 'ilike', wildcard: '%' },\n                    equals: { operator: '=', wildcard: '' },\n                    exists: { operator: val === true ? 'is not null' : 'is null' },\n                    like: { operator: 'like', wildcard: '%' },\n                    not_equals: { operator: '<>', wildcard: '' },\n                  }\n                  let formattedValue = `'${operatorKeys[operator].wildcard}${val}${operatorKeys[operator].wildcard}'`\n\n                  if (operator === 'exists') {\n                    formattedValue = ''\n                  }\n\n                  constraints.push(\n                    sql.raw(\n                      `${table[columnName].name}${jsonQuery} ${operatorKeys[operator].operator} ${formattedValue}`,\n                    ),\n                  )\n\n                  break\n                }\n\n                if (getNotNullColumnByValue) {\n                  const columnName = getNotNullColumnByValue(val)\n                  if (columnName) {\n                    constraints.push(isNotNull(table[columnName]))\n                  } else {\n                    throw new QueryError([{ path: relationOrPath }])\n                  }\n                  break\n                }\n\n                if (\n                  operator === 'like' &&\n                  (field.type === 'number' || table[columnName].columnType === 'PgUUID')\n                ) {\n                  operator = 'equals'\n                }\n\n                if (operator === 'like') {\n                  constraints.push(\n                    and(...val.split(' ').map((word) => ilike(table[columnName], `%${word}%`))),\n                  )\n                  break\n                }\n\n                const sanitizedQueryValue = sanitizeQueryValue({\n                  adapter,\n                  field,\n                  operator,\n                  relationOrPath,\n                  val,\n                })\n\n                if (sanitizedQueryValue === null) {\n                  break\n                }\n\n                const { operator: queryOperator, value: queryValue } = sanitizedQueryValue\n\n                if (queryOperator === 'not_equals' && queryValue !== null) {\n                  constraints.push(\n                    or(\n                      isNull(rawColumn || table[columnName]),\n                      /* eslint-disable @typescript-eslint/no-explicit-any */\n                      ne<any>(rawColumn || table[columnName], queryValue),\n                    ),\n                  )\n                  break\n                }\n\n                if (\n                  (field.type === 'relationship' || field.type === 'upload') &&\n                  Array.isArray(queryValue) &&\n                  operator === 'not_in'\n                ) {\n                  constraints.push(\n                    sql`(${notInArray(table[columnName], queryValue)} OR\n                    ${table[columnName]}\n                    IS\n                    NULL)`,\n                  )\n\n                  break\n                }\n\n                if (operator === 'equals' && queryValue === null) {\n                  constraints.push(isNull(rawColumn || table[columnName]))\n                  break\n                }\n\n                if (operator === 'not_equals' && queryValue === null) {\n                  constraints.push(isNotNull(rawColumn || table[columnName]))\n                  break\n                }\n\n                constraints.push(\n                  operatorMap[queryOperator](rawColumn || table[columnName], queryValue),\n                )\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (constraints.length > 0) {\n    if (result) {\n      result = and(result, ...constraints)\n    } else {\n      result = and(...constraints)\n    }\n  }\n  if (constraints.length === 1 && !result) {\n    ;[result] = constraints\n  }\n\n  return result\n}\n"],"names":["and","ilike","isNotNull","isNull","ne","notInArray","or","sql","QueryError","validOperators","buildAndOrConditions","convertPathToJSONTraversal","createJSONQuery","getTableColumnFromPath","operatorMap","sanitizeQueryValue","parseParams","adapter","fields","joins","locale","selectFields","tableName","where","result","constraints","Object","keys","length","relationOrPath","condition","conditionOperator","toLowerCase","Array","isArray","builtConditions","pathOperators","operator","includes","val","columnName","queryConstraints","field","getNotNullColumnByValue","pathSegments","rawColumn","table","collectionPath","replace","split","value","forEach","col","constraintTable","indexOf","push","like","equals","type","segments","slice","unshift","name","jsonQuery","treatAsArray","treatRootAsArray","raw","operatorKeys","contains","wildcard","exists","not_equals","formattedValue","path","columnType","map","word","sanitizedQueryValue","queryOperator","queryValue"],"mappings":"AAAA,mCAAmC,GAInC,SAASA,GAAG,EAAEC,KAAK,EAAEC,SAAS,EAAEC,MAAM,EAAEC,EAAE,EAAEC,UAAU,EAAEC,EAAE,EAAEC,GAAG,QAAQ,cAAa;AACpF,SAASC,UAAU,QAAQ,UAAS;AACpC,SAASC,cAAc,QAAQ,iBAAgB;AAK/C,SAASC,oBAAoB,QAAQ,4BAA2B;AAChE,SAASC,0BAA0B,QAAQ,kDAAiD;AAC5F,SAASC,eAAe,QAAQ,6BAA4B;AAC5D,SAASC,sBAAsB,QAAQ,8BAA6B;AACpE,SAASC,WAAW,QAAQ,mBAAkB;AAC9C,SAASC,kBAAkB,QAAQ,0BAAyB;AAY5D,OAAO,eAAeC,YAAY,EAChCC,OAAO,EACPC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,YAAY,EACZC,SAAS,EACTC,KAAK,EACA;IACL,IAAIC;IACJ,MAAMC,cAAqB,EAAE;IAE7B,IAAI,OAAOF,UAAU,YAAYG,OAAOC,IAAI,CAACJ,OAAOK,MAAM,GAAG,GAAG;QAC9D,uEAAuE;QACvE,KAAK,MAAMC,kBAAkBH,OAAOC,IAAI,CAACJ,OAAQ;YAC/C,IAAIM,gBAAgB;gBAClB,MAAMC,YAAYP,KAAK,CAACM,eAAe;gBACvC,IAAIE;gBACJ,IAAIF,eAAeG,WAAW,OAAO,OAAO;oBAC1CD,oBAAoB;gBACtB,OAAO,IAAIF,eAAeG,WAAW,OAAO,MAAM;oBAChDD,oBAAoB;gBACtB;gBACA,IAAIE,MAAMC,OAAO,CAACJ,YAAY;oBAC5B,MAAMK,kBAAkB,MAAMzB,qBAAqB;wBACjDO;wBACAC;wBACAC;wBACAC;wBACAC;wBACAC;wBACAC,OAAOO;oBACT;oBACA,IAAIK,gBAAgBP,MAAM,GAAG,GAAG;wBAC9BJ,SAASV,WAAW,CAACiB,kBAAkB,IAAII;oBAC7C;gBACF,OAAO;oBACL,wEAAwE;oBACxE,kEAAkE;oBAClE,8EAA8E;oBAC9E,MAAMC,gBAAgBb,KAAK,CAACM,eAAe;oBAC3C,IAAI,OAAOO,kBAAkB,UAAU;wBACrC,KAAK,IAAIC,YAAYX,OAAOC,IAAI,CAACS,eAAgB;4BAC/C,IAAI3B,eAAe6B,QAAQ,CAACD,WAAuB;gCACjD,MAAME,MAAMhB,KAAK,CAACM,eAAe,CAACQ,SAAS;gCAC3C,MAAM,EACJG,UAAU,EACVf,aAAagB,gBAAgB,EAC7BC,KAAK,EACLC,uBAAuB,EACvBC,YAAY,EACZC,SAAS,EACTC,KAAK,EACN,GAAGjC,uBAAuB;oCACzBI;oCACA8B,gBAAgBlB;oCAChBX;oCACAC;oCACAC;oCACAwB,cAAcf,eAAemB,OAAO,CAAC,OAAO,KAAKC,KAAK,CAAC;oCACvD5B;oCACAC;oCACA4B,OAAOX;gCACT;gCAEAE,iBAAiBU,OAAO,CAAC,CAAC,EAAEX,YAAYY,GAAG,EAAEN,OAAOO,eAAe,EAAEH,KAAK,EAAE;oCAC1E,IAAI,OAAOA,UAAU,YAAYA,MAAMI,OAAO,CAAC,OAAO,CAAC,GAAG;wCACxD7B,YAAY8B,IAAI,CAACzC,YAAY0C,IAAI,CAACH,eAAe,CAACD,IAAI,EAAEF;oCAC1D,OAAO;wCACLzB,YAAY8B,IAAI,CAACzC,YAAY2C,MAAM,CAACJ,eAAe,CAACD,IAAI,EAAEF;oCAC5D;gCACF;gCAEA,IACE;oCAAC;oCAAQ;iCAAW,CAACZ,QAAQ,CAACI,MAAMgB,IAAI,KACxCzB,MAAMC,OAAO,CAACU,iBACdA,aAAahB,MAAM,GAAG,GACtB;oCACA,MAAM+B,WAAWf,aAAagB,KAAK,CAAC;oCACpCD,SAASE,OAAO,CAACf,KAAK,CAACN,WAAW,CAACsB,IAAI;oCAEvC,IAAIpB,MAAMgB,IAAI,KAAK,YAAY;wCAC7B,MAAMK,YAAYnD,gBAAgB;4CAChCyB;4CACAO,cAAce;4CACdK,cAAc;gDAAC;6CAAW;4CAC1BC,kBAAkB;4CAClBf,OAAOX;wCACT;wCAEAd,YAAY8B,IAAI,CAAChD,IAAI2D,GAAG,CAACH;wCACzB;oCACF;oCAEA,MAAMA,YAAYpD,2BAA2BiC;oCAC7C,MAAMuB,eAAe;wCACnBC,UAAU;4CAAE/B,UAAU;4CAASgC,UAAU;wCAAI;wCAC7CZ,QAAQ;4CAAEpB,UAAU;4CAAKgC,UAAU;wCAAG;wCACtCC,QAAQ;4CAAEjC,UAAUE,QAAQ,OAAO,gBAAgB;wCAAU;wCAC7DiB,MAAM;4CAAEnB,UAAU;4CAAQgC,UAAU;wCAAI;wCACxCE,YAAY;4CAAElC,UAAU;4CAAMgC,UAAU;wCAAG;oCAC7C;oCACA,IAAIG,iBAAiB,CAAC,CAAC,EAAEL,YAAY,CAAC9B,SAAS,CAACgC,QAAQ,CAAC,EAAE9B,IAAI,EAAE4B,YAAY,CAAC9B,SAAS,CAACgC,QAAQ,CAAC,CAAC,CAAC;oCAEnG,IAAIhC,aAAa,UAAU;wCACzBmC,iBAAiB;oCACnB;oCAEA/C,YAAY8B,IAAI,CACdhD,IAAI2D,GAAG,CACL,CAAC,EAAEpB,KAAK,CAACN,WAAW,CAACsB,IAAI,CAAC,EAAEC,UAAU,CAAC,EAAEI,YAAY,CAAC9B,SAAS,CAACA,QAAQ,CAAC,CAAC,EAAEmC,eAAe,CAAC;oCAIhG;gCACF;gCAEA,IAAI7B,yBAAyB;oCAC3B,MAAMH,aAAaG,wBAAwBJ;oCAC3C,IAAIC,YAAY;wCACdf,YAAY8B,IAAI,CAACrD,UAAU4C,KAAK,CAACN,WAAW;oCAC9C,OAAO;wCACL,MAAM,IAAIhC,WAAW;4CAAC;gDAAEiE,MAAM5C;4CAAe;yCAAE;oCACjD;oCACA;gCACF;gCAEA,IACEQ,aAAa,UACZK,CAAAA,MAAMgB,IAAI,KAAK,YAAYZ,KAAK,CAACN,WAAW,CAACkC,UAAU,KAAK,QAAO,GACpE;oCACArC,WAAW;gCACb;gCAEA,IAAIA,aAAa,QAAQ;oCACvBZ,YAAY8B,IAAI,CACdvD,OAAOuC,IAAIU,KAAK,CAAC,KAAK0B,GAAG,CAAC,CAACC,OAAS3E,MAAM6C,KAAK,CAACN,WAAW,EAAE,CAAC,CAAC,EAAEoC,KAAK,CAAC,CAAC;oCAE1E;gCACF;gCAEA,MAAMC,sBAAsB9D,mBAAmB;oCAC7CE;oCACAyB;oCACAL;oCACAR;oCACAU;gCACF;gCAEA,IAAIsC,wBAAwB,MAAM;oCAChC;gCACF;gCAEA,MAAM,EAAExC,UAAUyC,aAAa,EAAE5B,OAAO6B,UAAU,EAAE,GAAGF;gCAEvD,IAAIC,kBAAkB,gBAAgBC,eAAe,MAAM;oCACzDtD,YAAY8B,IAAI,CACdjD,GACEH,OAAO0C,aAAaC,KAAK,CAACN,WAAW,GACrC,qDAAqD,GACrDpC,GAAQyC,aAAaC,KAAK,CAACN,WAAW,EAAEuC;oCAG5C;gCACF;gCAEA,IACE,AAACrC,CAAAA,MAAMgB,IAAI,KAAK,kBAAkBhB,MAAMgB,IAAI,KAAK,QAAO,KACxDzB,MAAMC,OAAO,CAAC6C,eACd1C,aAAa,UACb;oCACAZ,YAAY8B,IAAI,CACdhD,GAAG,CAAC,CAAC,EAAEF,WAAWyC,KAAK,CAACN,WAAW,EAAEuC,YAAY;oBACjD,EAAEjC,KAAK,CAACN,WAAW,CAAC;;yBAEf,CAAC;oCAGR;gCACF;gCAEA,IAAIH,aAAa,YAAY0C,eAAe,MAAM;oCAChDtD,YAAY8B,IAAI,CAACpD,OAAO0C,aAAaC,KAAK,CAACN,WAAW;oCACtD;gCACF;gCAEA,IAAIH,aAAa,gBAAgB0C,eAAe,MAAM;oCACpDtD,YAAY8B,IAAI,CAACrD,UAAU2C,aAAaC,KAAK,CAACN,WAAW;oCACzD;gCACF;gCAEAf,YAAY8B,IAAI,CACdzC,WAAW,CAACgE,cAAc,CAACjC,aAAaC,KAAK,CAACN,WAAW,EAAEuC;4BAE/D;wBACF;oBACF;gBACF;YACF;QACF;IACF;IACA,IAAItD,YAAYG,MAAM,GAAG,GAAG;QAC1B,IAAIJ,QAAQ;YACVA,SAASxB,IAAIwB,WAAWC;QAC1B,OAAO;YACLD,SAASxB,OAAOyB;QAClB;IACF;IACA,IAAIA,YAAYG,MAAM,KAAK,KAAK,CAACJ,QAAQ;QACtC,CAACA,OAAO,GAAGC;IACd;IAEA,OAAOD;AACT"}