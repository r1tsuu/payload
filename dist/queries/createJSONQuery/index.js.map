{"version":3,"sources":["../../../src/queries/createJSONQuery/index.ts"],"sourcesContent":["import { convertPathToJSONTraversal } from './convertPathToJSONTraversal.js'\nimport { formatJSONPathSegment } from './formatJSONPathSegment.js'\n\nconst operatorMap = {\n  contains: '~*',\n  equals: '=',\n  like: '~*',\n}\n\ntype FromArrayArgs = {\n  isRoot?: true\n  operator: string\n  pathSegments: string[]\n  treatAsArray?: string[]\n  value: unknown\n}\n\nconst fromArray = ({ isRoot, operator, pathSegments, treatAsArray, value }: FromArrayArgs) => {\n  const newPathSegments = pathSegments.slice(isRoot ? 1 : 2)\n  const alias = `${pathSegments[isRoot ? 0 : 1]}_alias_${newPathSegments.length}`\n\n  newPathSegments.unshift(alias)\n\n  const arrayElements = isRoot\n    ? pathSegments[0]\n    : `${pathSegments[0]} -> ${formatJSONPathSegment(pathSegments[1])}`\n\n  return `EXISTS (\n    SELECT 1\n    FROM jsonb_array_elements(${arrayElements}) AS ${alias}\n    WHERE ${createJSONQuery({\n      operator,\n      pathSegments: newPathSegments,\n      treatAsArray,\n      value,\n    })}\n  )`\n}\n\ntype CreateConstraintArgs = {\n  operator: string\n  pathSegments: string[]\n  treatAsArray?: string[]\n  value: unknown\n}\n\nconst createConstraint = ({ operator, pathSegments, value }: CreateConstraintArgs): string => {\n  const jsonQuery = convertPathToJSONTraversal(pathSegments)\n  return `${pathSegments[0]}${jsonQuery} ${operatorMap[operator]} '${value}'`\n}\n\ntype Args = {\n  operator: string\n  pathSegments: string[]\n  treatAsArray?: string[]\n  treatRootAsArray?: boolean\n  value: unknown\n}\n\nexport const createJSONQuery = ({\n  operator,\n  pathSegments,\n  treatAsArray,\n  treatRootAsArray,\n  value,\n}: Args): string => {\n  if (treatRootAsArray) {\n    return fromArray({\n      isRoot: true,\n      operator,\n      pathSegments,\n      treatAsArray,\n      value,\n    })\n  }\n\n  if (treatAsArray.includes(pathSegments[1])) {\n    return fromArray({\n      operator,\n      pathSegments,\n      treatAsArray,\n      value,\n    })\n  }\n\n  return createConstraint({ operator, pathSegments, treatAsArray, value })\n}\n"],"names":["convertPathToJSONTraversal","formatJSONPathSegment","operatorMap","contains","equals","like","fromArray","isRoot","operator","pathSegments","treatAsArray","value","newPathSegments","slice","alias","length","unshift","arrayElements","createJSONQuery","createConstraint","jsonQuery","treatRootAsArray","includes"],"mappings":"AAAA,SAASA,0BAA0B,QAAQ,kCAAiC;AAC5E,SAASC,qBAAqB,QAAQ,6BAA4B;AAElE,MAAMC,cAAc;IAClBC,UAAU;IACVC,QAAQ;IACRC,MAAM;AACR;AAUA,MAAMC,YAAY,CAAC,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,YAAY,EAAEC,KAAK,EAAiB;IACvF,MAAMC,kBAAkBH,aAAaI,KAAK,CAACN,SAAS,IAAI;IACxD,MAAMO,QAAQ,CAAC,EAAEL,YAAY,CAACF,SAAS,IAAI,EAAE,CAAC,OAAO,EAAEK,gBAAgBG,MAAM,CAAC,CAAC;IAE/EH,gBAAgBI,OAAO,CAACF;IAExB,MAAMG,gBAAgBV,SAClBE,YAAY,CAAC,EAAE,GACf,CAAC,EAAEA,YAAY,CAAC,EAAE,CAAC,IAAI,EAAER,sBAAsBQ,YAAY,CAAC,EAAE,EAAE,CAAC;IAErE,OAAO,CAAC;;8BAEoB,EAAEQ,cAAc,KAAK,EAAEH,MAAM;UACjD,EAAEI,gBAAgB;QACtBV;QACAC,cAAcG;QACdF;QACAC;IACF,GAAG;GACJ,CAAC;AACJ;AASA,MAAMQ,mBAAmB,CAAC,EAAEX,QAAQ,EAAEC,YAAY,EAAEE,KAAK,EAAwB;IAC/E,MAAMS,YAAYpB,2BAA2BS;IAC7C,OAAO,CAAC,EAAEA,YAAY,CAAC,EAAE,CAAC,EAAEW,UAAU,CAAC,EAAElB,WAAW,CAACM,SAAS,CAAC,EAAE,EAAEG,MAAM,CAAC,CAAC;AAC7E;AAUA,OAAO,MAAMO,kBAAkB,CAAC,EAC9BV,QAAQ,EACRC,YAAY,EACZC,YAAY,EACZW,gBAAgB,EAChBV,KAAK,EACA;IACL,IAAIU,kBAAkB;QACpB,OAAOf,UAAU;YACfC,QAAQ;YACRC;YACAC;YACAC;YACAC;QACF;IACF;IAEA,IAAID,aAAaY,QAAQ,CAACb,YAAY,CAAC,EAAE,GAAG;QAC1C,OAAOH,UAAU;YACfE;YACAC;YACAC;YACAC;QACF;IACF;IAEA,OAAOQ,iBAAiB;QAAEX;QAAUC;QAAcC;QAAcC;IAAM;AACxE,EAAC"}