{"version":3,"sources":["../../src/queries/getTableColumnFromPath.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { SQL } from 'drizzle-orm'\nimport type { PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport type { Field, FieldAffectingData, NumberField, TabAsField, TextField } from 'payload'\n\nimport { and, eq, like, sql } from 'drizzle-orm'\nimport { alias } from 'drizzle-orm/pg-core'\nimport { APIError, flattenTopLevelFields } from 'payload'\nimport { fieldAffectsData, tabHasName } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\nimport { v4 as uuid } from 'uuid'\n\nimport type { GenericColumn, GenericTable, PostgresAdapter } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\ntype Constraint = {\n  columnName: string\n  table: GenericTable | PgTableWithColumns<any>\n  value: unknown\n}\n\ntype TableColumn = {\n  columnName?: string\n  constraints: Constraint[]\n  field: FieldAffectingData\n  getNotNullColumnByValue?: (val: unknown) => string\n  pathSegments?: string[]\n  rawColumn?: SQL\n  table: GenericTable | PgTableWithColumns<any>\n}\n\ntype Args = {\n  adapter: PostgresAdapter\n  aliasTable?: GenericTable | PgTableWithColumns<any>\n  collectionPath: string\n  columnPrefix?: string\n  constraintPath?: string\n  constraints?: Constraint[]\n  fields: (Field | TabAsField)[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  pathSegments: string[]\n  rootTableName?: string\n  selectFields: Record<string, GenericColumn>\n  tableName: string\n  /**\n   * If creating a new table name for arrays and blocks, this suffix should be appended to the table name\n   */\n  tableNameSuffix?: string\n  /**\n   * The raw value of the query before sanitization\n   */\n  value: unknown\n}\n/**\n * Transforms path to table and column name\n * Adds tables to `join`\n * @returns TableColumn\n */\nexport const getTableColumnFromPath = ({\n  adapter,\n  aliasTable,\n  collectionPath,\n  columnPrefix = '',\n  constraintPath: incomingConstraintPath,\n  constraints = [],\n  fields,\n  joins,\n  locale: incomingLocale,\n  pathSegments: incomingSegments,\n  rootTableName: incomingRootTableName,\n  selectFields,\n  tableName,\n  tableNameSuffix = '',\n  value,\n}: Args): TableColumn => {\n  const fieldPath = incomingSegments[0]\n  let locale = incomingLocale\n  const rootTableName = incomingRootTableName || tableName\n  let constraintPath = incomingConstraintPath || ''\n\n  const field = flattenTopLevelFields(fields as Field[]).find(\n    (fieldToFind) => fieldAffectsData(fieldToFind) && fieldToFind.name === fieldPath,\n  ) as Field | TabAsField\n  let newTableName = tableName\n\n  if (!field && fieldPath === 'id') {\n    selectFields.id = adapter.tables[newTableName].id\n    return {\n      columnName: 'id',\n      constraints,\n      field: {\n        name: 'id',\n        type: adapter.idType === 'uuid' ? 'text' : 'number',\n      } as NumberField | TextField,\n      table: adapter.tables[newTableName],\n    }\n  }\n\n  if (field) {\n    const pathSegments = [...incomingSegments]\n\n    // If next segment is a locale,\n    // we need to take it out and use it as the locale from this point on\n    if ('localized' in field && field.localized && adapter.payload.config.localization) {\n      const matchedLocale = adapter.payload.config.localization.localeCodes.find(\n        (locale) => locale === pathSegments[1],\n      )\n\n      if (matchedLocale) {\n        locale = matchedLocale\n        pathSegments.splice(1, 1)\n      }\n    }\n\n    switch (field.type) {\n      case 'tabs': {\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.tabs.map((tab) => ({\n            ...tab,\n            type: 'tab',\n          })),\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n      case 'tab': {\n        if (tabHasName(field)) {\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable,\n            collectionPath,\n            columnPrefix: `${columnPrefix}${field.name}_`,\n            constraintPath: `${constraintPath}${field.name}.`,\n            constraints,\n            fields: field.fields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            rootTableName,\n            selectFields,\n            tableName: newTableName,\n            tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n            value,\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.fields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n\n      case 'group': {\n        if (locale && field.localized && adapter.payload.config.localization) {\n          newTableName = `${tableName}${adapter.localesSuffix}`\n\n          joins.push({\n            condition: eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID),\n            table: adapter.tables[newTableName],\n          })\n          if (locale !== 'all') {\n            constraints.push({\n              columnName: '_locale',\n              table: adapter.tables[newTableName],\n              value: locale,\n            })\n          }\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix: `${columnPrefix}${field.name}_`,\n          constraintPath: `${constraintPath}${field.name}.`,\n          constraints,\n          fields: field.fields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          tableName: newTableName,\n          tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n          value,\n        })\n      }\n\n      case 'select': {\n        if (field.hasMany) {\n          const newTableName = adapter.tableNameMap.get(\n            `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n          )\n\n          if (locale && field.localized && adapter.payload.config.localization) {\n            joins.push({\n              condition: and(\n                eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n                eq(adapter.tables[newTableName]._locale, locale),\n              ),\n              table: adapter.tables[newTableName],\n            })\n            if (locale !== 'all') {\n              constraints.push({\n                columnName: '_locale',\n                table: adapter.tables[newTableName],\n                value: locale,\n              })\n            }\n          } else {\n            joins.push({\n              condition: eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName: 'value',\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'text':\n      case 'number': {\n        if (field.hasMany) {\n          let tableType = 'texts'\n          let columnName = 'text'\n          if (field.type === 'number') {\n            tableType = 'numbers'\n            columnName = 'number'\n          }\n          newTableName = `${tableName}_${tableType}`\n          const joinConstraints = [\n            eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n            eq(adapter.tables[newTableName].path, `${constraintPath}${field.name}`),\n          ]\n\n          if (locale && field.localized && adapter.payload.config.localization) {\n            joins.push({\n              condition: and(...joinConstraints, eq(adapter.tables[newTableName]._locale, locale)),\n              table: adapter.tables[newTableName],\n            })\n            if (locale !== 'all') {\n              constraints.push({\n                columnName: 'locale',\n                table: adapter.tables[newTableName],\n                value: locale,\n              })\n            }\n          } else {\n            joins.push({\n              condition: and(...joinConstraints),\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName,\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'array': {\n        newTableName = adapter.tableNameMap.get(\n          `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n        )\n\n        constraintPath = `${constraintPath}${field.name}.%.`\n        if (locale && field.localized && adapter.payload.config.localization) {\n          joins.push({\n            condition: and(\n              eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID),\n              eq(adapter.tables[newTableName]._locale, locale),\n            ),\n            table: adapter.tables[newTableName],\n          })\n          if (locale !== 'all') {\n            constraints.push({\n              columnName: '_locale',\n              table: adapter.tables[newTableName],\n              value: locale,\n            })\n          }\n        } else {\n          joins.push({\n            condition: eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID),\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          collectionPath,\n          constraintPath,\n          constraints,\n          fields: field.fields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          tableName: newTableName,\n          value,\n        })\n      }\n\n      case 'blocks': {\n        let blockTableColumn: TableColumn\n        let newTableName: string\n\n        // handle blockType queries\n        if (pathSegments[1] === 'blockType') {\n          // find the block config using the value\n          const blockTypes = Array.isArray(value) ? value : [value]\n          blockTypes.forEach((blockType) => {\n            const block = field.blocks.find((block) => block.slug === blockType)\n            newTableName = adapter.tableNameMap.get(\n              `${tableName}_blocks_${toSnakeCase(block.slug)}`,\n            )\n            const newAliasTableName = toSnakeCase(uuid())\n            const newAliasTable = alias(adapter.tables[newTableName], newAliasTableName)\n\n            joins.push({\n              condition: eq(adapter.tables[tableName].id, newAliasTable._parentID),\n              table: newAliasTable,\n            })\n            constraints.push({\n              columnName: '_path',\n              table: newAliasTable,\n              value: pathSegments[0],\n            })\n          })\n          return {\n            constraints,\n            field,\n            getNotNullColumnByValue: () => 'id',\n            table: adapter.tables[tableName],\n          }\n        }\n\n        const hasBlockField = field.blocks.some((block) => {\n          newTableName = adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`)\n          constraintPath = `${constraintPath}${field.name}.%.`\n\n          let result\n          const blockConstraints = []\n          const blockSelectFields = {}\n          try {\n            result = getTableColumnFromPath({\n              adapter,\n              collectionPath,\n              constraintPath,\n              constraints: blockConstraints,\n              fields: block.fields,\n              joins,\n              locale,\n              pathSegments: pathSegments.slice(1),\n              rootTableName,\n              selectFields: blockSelectFields,\n              tableName: newTableName,\n              value,\n            })\n          } catch (error) {\n            // this is fine, not every block will have the field\n          }\n          if (!result) {\n            return\n          }\n          blockTableColumn = result\n          constraints = constraints.concat(blockConstraints)\n          selectFields = { ...selectFields, ...blockSelectFields }\n          if (field.localized && adapter.payload.config.localization) {\n            joins.push({\n              condition: and(\n                eq(\n                  (aliasTable || adapter.tables[tableName]).id,\n                  adapter.tables[newTableName]._parentID,\n                ),\n                eq(adapter.tables[newTableName]._locale, locale),\n              ),\n              table: adapter.tables[newTableName],\n            })\n            if (locale) {\n              constraints.push({\n                columnName: '_locale',\n                table: adapter.tables[newTableName],\n                value: locale,\n              })\n            }\n          } else {\n            joins.push({\n              condition: eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n              table: adapter.tables[newTableName],\n            })\n          }\n          return true\n        })\n        if (hasBlockField) {\n          return {\n            columnName: blockTableColumn.columnName,\n            constraints,\n            field: blockTableColumn.field,\n            pathSegments: pathSegments.slice(1),\n            rawColumn: blockTableColumn.rawColumn,\n            table: blockTableColumn.table,\n          }\n        }\n        break\n      }\n\n      case 'relationship':\n      case 'upload': {\n        const newCollectionPath = pathSegments.slice(1).join('.')\n        if (Array.isArray(field.relationTo) || (field.type === 'relationship' && field.hasMany)) {\n          let relationshipFields\n          const relationTableName = `${rootTableName}${adapter.relationshipsSuffix}`\n          const aliasRelationshipTableName = uuid()\n          const aliasRelationshipTable = alias(\n            adapter.tables[relationTableName],\n            aliasRelationshipTableName,\n          )\n\n          // Join in the relationships table\n          if (locale && field.localized && adapter.payload.config.localization) {\n            joins.push({\n              condition: and(\n                eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n                eq(aliasRelationshipTable.locale, locale),\n                like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n              ),\n              table: aliasRelationshipTable,\n            })\n            if (locale !== 'all') {\n              constraints.push({\n                columnName: 'locale',\n                table: aliasRelationshipTable,\n                value: locale,\n              })\n            }\n          } else {\n            // Join in the relationships table\n            joins.push({\n              condition: and(\n                eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n                like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n              ),\n              table: aliasRelationshipTable,\n            })\n          }\n\n          selectFields[`${relationTableName}.path`] = aliasRelationshipTable.path\n\n          let newAliasTable\n\n          if (typeof field.relationTo === 'string') {\n            const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n            newTableName = adapter.tableNameMap.get(toSnakeCase(relationshipConfig.slug))\n\n            // parent to relationship join table\n            relationshipFields = relationshipConfig.fields\n\n            newAliasTable = alias(adapter.tables[newTableName], toSnakeCase(uuid()))\n\n            joins.push({\n              condition: eq(newAliasTable.id, aliasRelationshipTable[`${field.relationTo}ID`]),\n              table: newAliasTable,\n            })\n\n            if (newCollectionPath === '' || newCollectionPath === 'id') {\n              return {\n                columnName: `${field.relationTo}ID`,\n                constraints,\n                field,\n                table: aliasRelationshipTable,\n              }\n            }\n          } else if (newCollectionPath === 'value') {\n            const tableColumnsNames = field.relationTo.map((relationTo) => {\n              const relationTableName = adapter.tableNameMap.get(\n                toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n              )\n\n              return `\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`\n            })\n            return {\n              constraints,\n              field,\n              rawColumn: sql.raw(`COALESCE(${tableColumnsNames.join(', ')})`),\n              table: aliasRelationshipTable,\n            }\n          } else if (newCollectionPath === 'relationTo') {\n            const relationTo = Array.isArray(field.relationTo)\n              ? field.relationTo\n              : [field.relationTo]\n\n            return {\n              constraints,\n              field,\n              getNotNullColumnByValue: (val) => {\n                const matchedRelation = relationTo.find((relation) => relation === val)\n                if (matchedRelation) return `${matchedRelation}ID`\n                return undefined\n              },\n              table: aliasRelationshipTable,\n            }\n          } else {\n            throw new APIError('Not supported')\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            fields: relationshipFields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: newTableName,\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        } else if (\n          pathSegments.length > 1 &&\n          !(pathSegments.length === 2 && pathSegments[1] === 'id')\n        ) {\n          // simple relationships\n          const columnName = `${columnPrefix}${field.name}`\n          const newTableName = adapter.tableNameMap.get(\n            toSnakeCase(adapter.payload.collections[field.relationTo].config.slug),\n          )\n          const aliasTableName = uuid()\n          const newAliasTable = alias(adapter.tables[newTableName], aliasTableName)\n\n          if (field.localized && adapter.payload.config.localization) {\n            const aliasLocaleTableName = uuid()\n            const aliasLocaleTable = alias(\n              adapter.tables[`${rootTableName}${adapter.localesSuffix}`],\n              aliasLocaleTableName,\n            )\n            joins.push({\n              condition: and(\n                eq(aliasLocaleTable._parentID, adapter.tables[rootTableName].id),\n                eq(aliasLocaleTable._locale, locale),\n              ),\n              table: aliasLocaleTable,\n            })\n            joins.push({\n              condition: eq(aliasLocaleTable[columnName], newAliasTable.id),\n              table: newAliasTable,\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                newAliasTable.id,\n                aliasTable ? aliasTable[columnName] : adapter.tables[tableName][columnName],\n              ),\n              table: newAliasTable,\n            })\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraintPath: '',\n            constraints,\n            fields: adapter.payload.collections[field.relationTo].config.fields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        }\n        break\n      }\n\n      default: {\n        // fall through\n        break\n      }\n    }\n\n    if (fieldAffectsData(field)) {\n      if (field.localized && adapter.payload.config.localization) {\n        // If localized, we go to localized table and set aliasTable to undefined\n        // so it is not picked up below to be used as targetTable\n        const parentTable = aliasTable || adapter.tables[tableName]\n        newTableName = `${tableName}${adapter.localesSuffix}`\n\n        joins.push({\n          condition: eq(parentTable.id, adapter.tables[newTableName]._parentID),\n          table: adapter.tables[newTableName],\n        })\n\n        aliasTable = undefined\n\n        if (locale !== 'all') {\n          constraints.push({\n            columnName: '_locale',\n            table: adapter.tables[newTableName],\n            value: locale,\n          })\n        }\n      }\n\n      const targetTable = aliasTable || adapter.tables[newTableName]\n\n      selectFields[`${newTableName}.${columnPrefix}${field.name}`] =\n        targetTable[`${columnPrefix}${field.name}`]\n\n      return {\n        columnName: `${columnPrefix}${field.name}`,\n        constraints,\n        field,\n        pathSegments,\n        table: targetTable,\n      }\n    }\n  }\n\n  throw new APIError(`Cannot find field for path at ${fieldPath}`)\n}\n"],"names":["and","eq","like","sql","alias","APIError","flattenTopLevelFields","fieldAffectsData","tabHasName","toSnakeCase","v4","uuid","getTableColumnFromPath","adapter","aliasTable","collectionPath","columnPrefix","constraintPath","incomingConstraintPath","constraints","fields","joins","locale","incomingLocale","pathSegments","incomingSegments","rootTableName","incomingRootTableName","selectFields","tableName","tableNameSuffix","value","fieldPath","field","find","fieldToFind","name","newTableName","id","tables","columnName","type","idType","table","localized","payload","config","localization","matchedLocale","localeCodes","splice","tabs","map","tab","slice","localesSuffix","push","condition","_parentID","hasMany","tableNameMap","get","parent","_locale","tableType","joinConstraints","path","blockTableColumn","blockTypes","Array","isArray","forEach","blockType","block","blocks","slug","newAliasTableName","newAliasTable","getNotNullColumnByValue","hasBlockField","some","result","blockConstraints","blockSelectFields","error","concat","rawColumn","newCollectionPath","join","relationTo","relationshipFields","relationTableName","relationshipsSuffix","aliasRelationshipTableName","aliasRelationshipTable","relationshipConfig","collections","tableColumnsNames","raw","val","matchedRelation","relation","undefined","length","aliasTableName","aliasLocaleTableName","aliasLocaleTable","parentTable","targetTable"],"mappings":"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"}