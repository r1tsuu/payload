{"version":3,"sources":["../../src/queries/sanitizeQueryValue.ts"],"sourcesContent":["import { APIError, type Field, type TabAsField, createArrayFromCommaDelineated } from 'payload'\nimport { fieldAffectsData } from 'payload/shared'\n\nimport type { PostgresAdapter } from '../types.js'\n\ntype SanitizeQueryValueArgs = {\n  adapter: PostgresAdapter\n  field: Field | TabAsField\n  operator: string\n  relationOrPath: string\n  val: any\n}\n\nexport const sanitizeQueryValue = ({\n  adapter,\n  field,\n  operator: operatorArg,\n  relationOrPath,\n  val,\n}: SanitizeQueryValueArgs): { operator: string; value: unknown } => {\n  let operator = operatorArg\n  let formattedValue = val\n\n  if (!fieldAffectsData(field)) return { operator, value: formattedValue }\n\n  if (\n    (field.type === 'relationship' || field.type === 'upload') &&\n    !relationOrPath.endsWith('relationTo') &&\n    Array.isArray(formattedValue)\n  ) {\n    const allPossibleIDTypes: (number | string)[] = []\n    formattedValue.forEach((val) => {\n      if (adapter.idType !== 'uuid' && typeof val === 'string') {\n        allPossibleIDTypes.push(val, parseInt(val))\n      } else if (typeof val === 'string') {\n        allPossibleIDTypes.push(val)\n      } else {\n        allPossibleIDTypes.push(val, String(val))\n      }\n    })\n    formattedValue = allPossibleIDTypes\n  }\n\n  // Cast incoming values as proper searchable types\n  if (field.type === 'checkbox' && typeof val === 'string') {\n    if (val.toLowerCase() === 'true') formattedValue = true\n    if (val.toLowerCase() === 'false') formattedValue = false\n  }\n\n  if (['all', 'in', 'not_in'].includes(operator)) {\n    if (typeof formattedValue === 'string') {\n      formattedValue = createArrayFromCommaDelineated(formattedValue)\n\n      if (field.type === 'number') {\n        formattedValue = formattedValue.map((arrayVal) => parseFloat(arrayVal))\n      }\n    }\n\n    if (!Array.isArray(formattedValue) || formattedValue.length === 0) {\n      return null\n    }\n  }\n\n  if (field.type === 'number' && typeof formattedValue === 'string') {\n    formattedValue = Number(val)\n  }\n\n  if (field.type === 'date' && operator !== 'exists') {\n    if (typeof val === 'string') {\n      formattedValue = new Date(val)\n      if (Number.isNaN(Date.parse(formattedValue))) {\n        return { operator, value: undefined }\n      }\n    }\n\n    if (typeof val === 'number') {\n      formattedValue = new Date(val)\n    }\n  }\n\n  if (['relationship', 'upload'].includes(field.type)) {\n    if (val === 'null') {\n      formattedValue = null\n    }\n  }\n\n  if ('hasMany' in field && field.hasMany && operator === 'contains') {\n    operator = 'equals'\n  }\n\n  if (operator === 'near' || operator === 'within' || operator === 'intersects') {\n    throw new APIError(\n      `Querying with '${operator}' is not supported with the postgres database adapter.`,\n    )\n  }\n\n  if (operator === 'contains') {\n    formattedValue = `%${formattedValue}%`\n  }\n\n  if (operator === 'exists') {\n    formattedValue = formattedValue === 'true' || formattedValue === true\n    if (formattedValue === false) {\n      operator = 'isNull'\n    }\n  }\n\n  return { operator, value: formattedValue }\n}\n"],"names":["APIError","createArrayFromCommaDelineated","fieldAffectsData","sanitizeQueryValue","adapter","field","operator","operatorArg","relationOrPath","val","formattedValue","value","type","endsWith","Array","isArray","allPossibleIDTypes","forEach","idType","push","parseInt","String","toLowerCase","includes","map","arrayVal","parseFloat","length","Number","Date","isNaN","parse","undefined","hasMany"],"mappings":"AAAA,SAASA,QAAQ,EAA+BC,8BAA8B,QAAQ,UAAS;AAC/F,SAASC,gBAAgB,QAAQ,iBAAgB;AAYjD,OAAO,MAAMC,qBAAqB,CAAC,EACjCC,OAAO,EACPC,KAAK,EACLC,UAAUC,WAAW,EACrBC,cAAc,EACdC,GAAG,EACoB;IACvB,IAAIH,WAAWC;IACf,IAAIG,iBAAiBD;IAErB,IAAI,CAACP,iBAAiBG,QAAQ,OAAO;QAAEC;QAAUK,OAAOD;IAAe;IAEvE,IACE,AAACL,CAAAA,MAAMO,IAAI,KAAK,kBAAkBP,MAAMO,IAAI,KAAK,QAAO,KACxD,CAACJ,eAAeK,QAAQ,CAAC,iBACzBC,MAAMC,OAAO,CAACL,iBACd;QACA,MAAMM,qBAA0C,EAAE;QAClDN,eAAeO,OAAO,CAAC,CAACR;YACtB,IAAIL,QAAQc,MAAM,KAAK,UAAU,OAAOT,QAAQ,UAAU;gBACxDO,mBAAmBG,IAAI,CAACV,KAAKW,SAASX;YACxC,OAAO,IAAI,OAAOA,QAAQ,UAAU;gBAClCO,mBAAmBG,IAAI,CAACV;YAC1B,OAAO;gBACLO,mBAAmBG,IAAI,CAACV,KAAKY,OAAOZ;YACtC;QACF;QACAC,iBAAiBM;IACnB;IAEA,kDAAkD;IAClD,IAAIX,MAAMO,IAAI,KAAK,cAAc,OAAOH,QAAQ,UAAU;QACxD,IAAIA,IAAIa,WAAW,OAAO,QAAQZ,iBAAiB;QACnD,IAAID,IAAIa,WAAW,OAAO,SAASZ,iBAAiB;IACtD;IAEA,IAAI;QAAC;QAAO;QAAM;KAAS,CAACa,QAAQ,CAACjB,WAAW;QAC9C,IAAI,OAAOI,mBAAmB,UAAU;YACtCA,iBAAiBT,+BAA+BS;YAEhD,IAAIL,MAAMO,IAAI,KAAK,UAAU;gBAC3BF,iBAAiBA,eAAec,GAAG,CAAC,CAACC,WAAaC,WAAWD;YAC/D;QACF;QAEA,IAAI,CAACX,MAAMC,OAAO,CAACL,mBAAmBA,eAAeiB,MAAM,KAAK,GAAG;YACjE,OAAO;QACT;IACF;IAEA,IAAItB,MAAMO,IAAI,KAAK,YAAY,OAAOF,mBAAmB,UAAU;QACjEA,iBAAiBkB,OAAOnB;IAC1B;IAEA,IAAIJ,MAAMO,IAAI,KAAK,UAAUN,aAAa,UAAU;QAClD,IAAI,OAAOG,QAAQ,UAAU;YAC3BC,iBAAiB,IAAImB,KAAKpB;YAC1B,IAAImB,OAAOE,KAAK,CAACD,KAAKE,KAAK,CAACrB,kBAAkB;gBAC5C,OAAO;oBAAEJ;oBAAUK,OAAOqB;gBAAU;YACtC;QACF;QAEA,IAAI,OAAOvB,QAAQ,UAAU;YAC3BC,iBAAiB,IAAImB,KAAKpB;QAC5B;IACF;IAEA,IAAI;QAAC;QAAgB;KAAS,CAACc,QAAQ,CAAClB,MAAMO,IAAI,GAAG;QACnD,IAAIH,QAAQ,QAAQ;YAClBC,iBAAiB;QACnB;IACF;IAEA,IAAI,aAAaL,SAASA,MAAM4B,OAAO,IAAI3B,aAAa,YAAY;QAClEA,WAAW;IACb;IAEA,IAAIA,aAAa,UAAUA,aAAa,YAAYA,aAAa,cAAc;QAC7E,MAAM,IAAIN,SACR,CAAC,eAAe,EAAEM,SAAS,sDAAsD,CAAC;IAEtF;IAEA,IAAIA,aAAa,YAAY;QAC3BI,iBAAiB,CAAC,CAAC,EAAEA,eAAe,CAAC,CAAC;IACxC;IAEA,IAAIJ,aAAa,UAAU;QACzBI,iBAAiBA,mBAAmB,UAAUA,mBAAmB;QACjE,IAAIA,mBAAmB,OAAO;YAC5BJ,WAAW;QACb;IACF;IAEA,OAAO;QAAEA;QAAUK,OAAOD;IAAe;AAC3C,EAAC"}