{"version":3,"sources":["../../src/database/types.ts"],"sourcesContent":["import type { TypeWithID } from '../collections/config/types.js'\nimport type { Document, Payload, PayloadRequestWithData, Where } from '../types/index.js'\nimport type { TypeWithVersion } from '../versions/types.js'\n\nexport type { TypeWithVersion }\n\nexport interface BaseDatabaseAdapter {\n  /**\n   * Start a transaction, requiring commitTransaction() to be called for any changes to be made.\n   * @returns an identifier for the transaction or null if one cannot be established\n   */\n  beginTransaction?: BeginTransaction\n  /**\n   * Persist the changes made since the start of the transaction.\n   */\n  commitTransaction?: CommitTransaction\n\n  /**\n   * Open the connection to the database\n   */\n  connect?: Connect\n\n  count: Count\n\n  create: Create\n\n  createGlobal: CreateGlobal\n\n  createGlobalVersion: CreateGlobalVersion\n  /**\n   * Output a migration file\n   */\n  createMigration: CreateMigration\n\n  createVersion: CreateVersion\n\n  /**\n   * Specify if the ID is a text or number field by default within this database adapter.\n   */\n  defaultIDType: 'number' | 'text'\n\n  deleteMany: DeleteMany\n\n  deleteOne: DeleteOne\n\n  deleteVersions: DeleteVersions\n\n  /**\n   * Terminate the connection with the database\n   */\n  destroy?: Destroy\n\n  find: <T = TypeWithID>(args: FindArgs) => Promise<PaginatedDocs<T>>\n\n  findGlobal: FindGlobal\n\n  findGlobalVersions: FindGlobalVersions\n\n  findOne: FindOne\n\n  findVersions: FindVersions\n\n  /**\n   * Perform startup tasks required to interact with the database such as building Schema and models\n   */\n  init?: Init\n\n  /**\n   * Run any migration up functions that have not yet been performed and update the status\n   */\n  migrate: () => Promise<void>\n\n  /**\n   * Run any migration down functions that have been performed\n   */\n  migrateDown: () => Promise<void>\n\n  /**\n   * Drop the current database and run all migrate up functions\n   */\n  migrateFresh: (args: { forceAcceptWarning?: boolean }) => Promise<void>\n  /**\n   * Run all migration down functions before running up\n   */\n  migrateRefresh: () => Promise<void>\n\n  /**\n   * Run all migrate down functions\n   */\n  migrateReset: () => Promise<void>\n  /**\n   * Read the current state of migrations and output the result to show which have been run\n   */\n  migrateStatus: () => Promise<void>\n  /**\n   * Path to read and write migration files from\n   */\n  migrationDir: string\n  /**\n   * The name of the database adapter\n   */\n  name: string\n  /**\n   * reference to the instance of payload\n   */\n  payload: Payload\n\n  queryDrafts: QueryDrafts\n  /**\n   * Abort any changes since the start of the transaction.\n   */\n  rollbackTransaction?: RollbackTransaction\n  /**\n   * A key-value store of all sessions open (used for transactions)\n   */\n  sessions?: {\n    [id: string]: {\n      db: unknown\n      reject: () => Promise<void>\n      resolve: () => Promise<void>\n    }\n  }\n\n  updateGlobal: UpdateGlobal\n\n  updateGlobalVersion: UpdateGlobalVersion\n\n  updateOne: UpdateOne\n\n  updateVersion: UpdateVersion\n}\n\nexport type Init = () => Promise<void> | void\n\ntype ConnectArgs = {\n  hotReload: boolean\n}\n\nexport type Connect = (args?: ConnectArgs) => Promise<void>\n\nexport type Destroy = () => Promise<void>\n\nexport type CreateMigration = (args: {\n  file?: string\n  /**\n   * Skips the prompt asking to create empty migrations\n   */\n  forceAcceptWarning?: boolean\n  migrationName?: string\n  payload: Payload\n}) => Promise<void>\n\nexport type Transaction = (\n  callback: () => Promise<void>,\n  options?: Record<string, unknown>,\n) => Promise<void>\n\nexport type BeginTransaction = (\n  options?: Record<string, unknown>,\n) => Promise<null | number | string>\n\nexport type RollbackTransaction = (id: number | string) => Promise<void>\n\nexport type CommitTransaction = (id: number | string) => Promise<void>\n\nexport type QueryDraftsArgs = {\n  collection: string\n  limit?: number\n  locale?: string\n  page?: number\n  pagination?: boolean\n  req: PayloadRequestWithData\n  sort?: string\n  where?: Where\n}\n\nexport type QueryDrafts = <T = TypeWithID>(args: QueryDraftsArgs) => Promise<PaginatedDocs<T>>\n\nexport type FindOneArgs = {\n  collection: string\n  locale?: string\n  req: PayloadRequestWithData\n  where?: Where\n}\n\nexport type FindOne = <T extends TypeWithID>(args: FindOneArgs) => Promise<T | null>\n\nexport type FindArgs = {\n  collection: string\n  /** Setting limit to 1 is equal to the previous Model.findOne(). Setting limit to 0 disables the limit */\n  limit?: number\n  locale?: string\n  page?: number\n  pagination?: boolean\n  req: PayloadRequestWithData\n  skip?: number\n  sort?: string\n  versions?: boolean\n  where?: Where\n}\n\nexport type Find = <T = TypeWithID>(args: FindArgs) => Promise<PaginatedDocs<T>>\n\nexport type CountArgs = {\n  collection: string\n  locale?: string\n  req: PayloadRequestWithData\n  where?: Where\n}\n\nexport type Count = (args: CountArgs) => Promise<{ totalDocs: number }>\n\ntype BaseVersionArgs = {\n  limit?: number\n  locale?: string\n  page?: number\n  pagination?: boolean\n  req: PayloadRequestWithData\n  skip?: number\n  sort?: string\n  versions?: boolean\n  where?: Where\n}\n\nexport type FindVersionsArgs = BaseVersionArgs & {\n  collection: string\n}\n\nexport type FindVersions = <T = TypeWithID>(\n  args: FindVersionsArgs,\n) => Promise<PaginatedDocs<TypeWithVersion<T>>>\n\nexport type FindGlobalVersionsArgs = BaseVersionArgs & {\n  global: string\n}\n\nexport type FindGlobalArgs = {\n  locale?: string\n  req: PayloadRequestWithData\n  slug: string\n  where?: Where\n}\n\nexport type UpdateGlobalVersionArgs<T = TypeWithID> = {\n  global: string\n  locale?: string\n  req: PayloadRequestWithData\n  versionData: T\n} & (\n  | {\n      id: number | string\n      where?: never\n    }\n  | {\n      id?: never\n      where: Where\n    }\n)\n\nexport type UpdateGlobalVersion = <T extends TypeWithID = TypeWithID>(\n  args: UpdateGlobalVersionArgs<T>,\n) => Promise<TypeWithVersion<T>>\n\nexport type FindGlobal = <T extends Record<string, unknown> = any>(\n  args: FindGlobalArgs,\n) => Promise<T>\n\nexport type CreateGlobalArgs<T extends Record<string, unknown> = any> = {\n  data: T\n  req: PayloadRequestWithData\n  slug: string\n}\nexport type CreateGlobal = <T extends Record<string, unknown> = any>(\n  args: CreateGlobalArgs<T>,\n) => Promise<T>\n\nexport type UpdateGlobalArgs<T extends Record<string, unknown> = any> = {\n  data: T\n  req: PayloadRequestWithData\n  slug: string\n}\nexport type UpdateGlobal = <T extends Record<string, unknown> = any>(\n  args: UpdateGlobalArgs<T>,\n) => Promise<T>\n// export type UpdateOne = (args: UpdateOneArgs) => Promise<Document>\n\nexport type FindGlobalVersions = <T = TypeWithID>(\n  args: FindGlobalVersionsArgs,\n) => Promise<PaginatedDocs<TypeWithVersion<T>>>\n\nexport type DeleteVersionsArgs = {\n  collection: string\n  locale?: string\n  req: PayloadRequestWithData\n  sort?: {\n    [key: string]: string\n  }\n  where: Where\n}\n\nexport type CreateVersionArgs<T = TypeWithID> = {\n  autosave: boolean\n  collectionSlug: string\n  createdAt: string\n  /** ID of the parent document for which the version should be created for */\n  parent: number | string\n  req: PayloadRequestWithData\n  updatedAt: string\n  versionData: T\n}\n\nexport type CreateVersion = <T extends TypeWithID = TypeWithID>(\n  args: CreateVersionArgs<T>,\n) => Promise<TypeWithVersion<T>>\n\nexport type CreateGlobalVersionArgs<T = TypeWithID> = {\n  autosave: boolean\n  createdAt: string\n  globalSlug: string\n  /** ID of the parent document for which the version should be created for */\n  parent: number | string\n  req: PayloadRequestWithData\n  updatedAt: string\n  versionData: T\n}\n\nexport type CreateGlobalVersion = <T extends TypeWithID = TypeWithID>(\n  args: CreateGlobalVersionArgs<T>,\n) => Promise<TypeWithVersion<T>>\n\nexport type DeleteVersions = (args: DeleteVersionsArgs) => Promise<void>\n\nexport type UpdateVersionArgs<T = TypeWithID> = {\n  collection: string\n  locale?: string\n  req: PayloadRequestWithData\n  versionData: T\n} & (\n  | {\n      id: number | string\n      where?: never\n    }\n  | {\n      id?: never\n      where: Where\n    }\n)\n\nexport type UpdateVersion = <T extends TypeWithID = TypeWithID>(\n  args: UpdateVersionArgs<T>,\n) => Promise<TypeWithVersion<T>>\n\nexport type CreateArgs = {\n  collection: string\n  data: Record<string, unknown>\n  draft?: boolean\n  locale?: string\n  req: PayloadRequestWithData\n}\n\nexport type Create = (args: CreateArgs) => Promise<Document>\n\nexport type UpdateOneArgs = {\n  collection: string\n  data: Record<string, unknown>\n  draft?: boolean\n  locale?: string\n  req: PayloadRequestWithData\n} & (\n  | {\n      id: number | string\n      where?: never\n    }\n  | {\n      id?: never\n      where: Where\n    }\n)\n\nexport type UpdateOne = (args: UpdateOneArgs) => Promise<Document>\n\nexport type DeleteOneArgs = {\n  collection: string\n  req: PayloadRequestWithData\n  where: Where\n}\n\nexport type DeleteOne = (args: DeleteOneArgs) => Promise<Document>\n\nexport type DeleteManyArgs = {\n  collection: string\n  req: PayloadRequestWithData\n  where: Where\n}\n\nexport type DeleteMany = (args: DeleteManyArgs) => Promise<void>\n\nexport type Migration = MigrationData & {\n  down: ({ payload, req }: { payload: Payload; req: PayloadRequestWithData }) => Promise<boolean>\n  up: ({ payload, req }: { payload: Payload; req: PayloadRequestWithData }) => Promise<boolean>\n}\n\nexport type MigrationData = {\n  batch?: number\n  id?: string\n  name: string\n}\n\nexport type PaginatedDocs<T = any> = {\n  docs: T[]\n  hasNextPage: boolean\n  hasPrevPage: boolean\n  limit: number\n  nextPage?: null | number | undefined\n  page?: number\n  pagingCounter: number\n  prevPage?: null | number | undefined\n  totalDocs: number\n  totalPages: number\n}\n\nexport type DatabaseAdapterResult<T = BaseDatabaseAdapter> = {\n  defaultIDType: 'number' | 'text'\n  init: (args: { payload: Payload }) => T\n}\n\nexport type DBIdentifierName =\n  | ((Args: {\n      /** The name of the parent table when using relational DBs */\n      tableName?: string\n    }) => string)\n  | string\n\nexport type MigrationTemplateArgs = {\n  downSQL?: string\n  imports?: string\n  upSQL?: string\n}\n"],"names":[],"mappings":"AAibA,WAIC"}