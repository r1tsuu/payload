{"version":3,"sources":["../../src/database/getLocalizedPaths.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PathToQuery } from './queryValidation/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport flattenFields from '../utilities/flattenTopLevelFields.js'\n\nexport async function getLocalizedPaths({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  overrideAccess = false,\n  payload,\n}: {\n  collectionSlug?: string\n  fields: Field[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  overrideAccess?: boolean\n  payload: Payload\n}): Promise<PathToQuery[]> {\n  const pathSegments = incomingPath.split('.')\n  const localizationConfig = payload.config.localization\n\n  let paths: PathToQuery[] = [\n    {\n      collectionSlug,\n      complete: false,\n      field: undefined,\n      fields: flattenFields(fields, false),\n      globalSlug,\n      invalid: false,\n      path: '',\n    },\n  ]\n\n  for (let i = 0; i < pathSegments.length; i += 1) {\n    const segment = pathSegments[i]\n\n    const lastIncompletePath = paths.find(({ complete }) => !complete)\n\n    if (lastIncompletePath) {\n      const { path } = lastIncompletePath\n      let currentPath = path ? `${path}.${segment}` : segment\n\n      const matchedField = lastIncompletePath.fields.find(\n        (field) => fieldAffectsData(field) && field.name === segment,\n      )\n      lastIncompletePath.field = matchedField\n\n      if (currentPath === 'globalType' && globalSlug) {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'globalType',\n          type: 'text',\n        }\n\n        return paths\n      }\n\n      if (!matchedField && currentPath === 'id' && i === pathSegments.length - 1) {\n        lastIncompletePath.path = currentPath\n        const idField: Field = {\n          name: 'id',\n          type: payload.db.defaultIDType as 'text',\n        }\n        lastIncompletePath.field = idField\n        lastIncompletePath.complete = true\n        return paths\n      }\n\n      if (matchedField) {\n        if ('hidden' in matchedField && matchedField.hidden && !overrideAccess) {\n          lastIncompletePath.invalid = true\n        }\n\n        const nextSegment = pathSegments[i + 1]\n        const nextSegmentIsLocale =\n          localizationConfig && localizationConfig.localeCodes.includes(nextSegment)\n\n        if (nextSegmentIsLocale) {\n          // Skip the next iteration, because it's a locale\n          i += 1\n          currentPath = `${currentPath}.${nextSegment}`\n        } else if (localizationConfig && 'localized' in matchedField && matchedField.localized) {\n          currentPath = `${currentPath}.${locale}`\n        }\n\n        switch (matchedField.type) {\n          case 'blocks':\n          case 'richText':\n          case 'json': {\n            const upcomingSegments = pathSegments.slice(i + 1).join('.')\n            lastIncompletePath.complete = true\n            lastIncompletePath.path = upcomingSegments\n              ? `${currentPath}.${upcomingSegments}`\n              : currentPath\n            return paths\n          }\n\n          case 'relationship':\n          case 'upload': {\n            // If this is a polymorphic relation,\n            // We only support querying directly (no nested querying)\n            if (typeof matchedField.relationTo !== 'string') {\n              const lastSegmentIsValid =\n                ['relationTo', 'value'].includes(pathSegments[pathSegments.length - 1]) ||\n                pathSegments.length === 1\n\n              if (lastSegmentIsValid) {\n                lastIncompletePath.complete = true\n                lastIncompletePath.path = pathSegments.join('.')\n              } else {\n                lastIncompletePath.invalid = true\n                return paths\n              }\n            } else {\n              lastIncompletePath.complete = true\n              lastIncompletePath.path = currentPath\n\n              const nestedPathToQuery = pathSegments\n                .slice(nextSegmentIsLocale ? i + 2 : i + 1)\n                .join('.')\n\n              if (nestedPathToQuery) {\n                const relatedCollection = payload.collections[matchedField.relationTo].config\n\n                // eslint-disable-next-line no-await-in-loop\n                const remainingPaths = await getLocalizedPaths({\n                  collectionSlug: relatedCollection.slug,\n                  fields: relatedCollection.fields,\n                  globalSlug,\n                  incomingPath: nestedPathToQuery,\n                  locale,\n                  payload,\n                })\n\n                paths = [...paths, ...remainingPaths]\n              }\n\n              return paths\n            }\n\n            break\n          }\n\n          default: {\n            if ('fields' in lastIncompletePath.field) {\n              lastIncompletePath.fields = flattenFields(lastIncompletePath.field.fields, false)\n            }\n\n            if (i + 1 === pathSegments.length) lastIncompletePath.complete = true\n            lastIncompletePath.path = currentPath\n          }\n        }\n      } else {\n        lastIncompletePath.invalid = true\n        lastIncompletePath.path = currentPath\n        return paths\n      }\n    }\n  }\n\n  return paths\n}\n"],"names":["fieldAffectsData","flattenFields","getLocalizedPaths","collectionSlug","fields","globalSlug","incomingPath","locale","overrideAccess","payload","pathSegments","split","localizationConfig","config","localization","paths","complete","field","undefined","invalid","path","i","length","segment","lastIncompletePath","find","currentPath","matchedField","name","type","idField","db","defaultIDType","hidden","nextSegment","nextSegmentIsLocale","localeCodes","includes","localized","upcomingSegments","slice","join","relationTo","lastSegmentIsValid","nestedPathToQuery","relatedCollection","collections","remainingPaths","slug"],"mappings":"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"}