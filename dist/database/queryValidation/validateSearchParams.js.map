{"version":3,"sources":["../../../src/database/queryValidation/validateSearchParams.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { Field } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequestWithData } from '../../types/index.js'\nimport type { EntityPolicies, PathToQuery } from './types.js'\n\nimport { fieldAffectsData } from '../../fields/config/types.js'\nimport { getEntityPolicies } from '../../utilities/getEntityPolicies.js'\nimport isolateObjectProperty from '../../utilities/isolateObjectProperty.js'\nimport { getLocalizedPaths } from '../getLocalizedPaths.js'\nimport { validateQueryPaths } from './validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig?: SanitizedCollectionConfig\n  errors: { path: string }[]\n  fields: Field[]\n  globalConfig?: SanitizedGlobalConfig\n  operator: string\n  overrideAccess: boolean\n  path: string\n  policies: EntityPolicies\n  req: PayloadRequestWithData\n  val: unknown\n  versionFields?: Field[]\n}\n\n/**\n * Validate the Payload key / value / operator\n */\nexport async function validateSearchParam({\n  collectionConfig,\n  errors,\n  fields,\n  globalConfig,\n  operator,\n  overrideAccess,\n  path: incomingPath,\n  policies,\n  req,\n  val,\n  versionFields,\n}: Args): Promise<void> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath\n  if (incomingPath === '_id') {\n    sanitizedPath = 'id'\n  } else {\n    sanitizedPath = incomingPath.replace(/__/g, '.')\n  }\n  let paths: PathToQuery[] = []\n  const { slug } = collectionConfig || globalConfig\n\n  if (globalConfig && !policies.globals[slug]) {\n    // eslint-disable-next-line no-param-reassign\n    globalConfig.fields = fields\n\n    // eslint-disable-next-line no-param-reassign\n    policies.globals[slug] = await getEntityPolicies({\n      type: 'global',\n      entity: globalConfig,\n      operations: ['read'],\n      req,\n    })\n  }\n\n  if (sanitizedPath !== 'id') {\n    paths = await getLocalizedPaths({\n      collectionSlug: collectionConfig?.slug,\n      fields,\n      globalSlug: globalConfig?.slug,\n      incomingPath: sanitizedPath,\n      locale: req.locale,\n      overrideAccess,\n      payload: req.payload,\n    })\n  }\n  const promises = []\n  promises.push(\n    ...paths.map(async ({ collectionSlug, field, invalid, path }, i) => {\n      if (invalid) {\n        errors.push({ path })\n        return\n      }\n\n      if (!overrideAccess && fieldAffectsData(field)) {\n        if (collectionSlug) {\n          if (!policies.collections[collectionSlug]) {\n            // eslint-disable-next-line no-param-reassign\n            policies.collections[collectionSlug] = await getEntityPolicies({\n              type: 'collection',\n              entity: req.payload.collections[collectionSlug].config,\n              operations: ['read'],\n              req: isolateObjectProperty(req, 'transactionID'),\n            })\n          }\n\n          if (\n            ['hash', 'salt'].includes(incomingPath) &&\n            collectionConfig.auth &&\n            !collectionConfig.auth?.disableLocalStrategy\n          ) {\n            errors.push({ path: incomingPath })\n          }\n        }\n        let fieldPath = path\n        // remove locale from end of path\n        if (path.endsWith(`.${req.locale}`)) {\n          fieldPath = path.slice(0, -(req.locale.length + 1))\n        }\n        // remove \".value\" from ends of polymorphic relationship paths\n        if (field.type === 'relationship' && Array.isArray(field.relationTo)) {\n          fieldPath = fieldPath.replace('.value', '')\n        }\n        const entityType: 'collections' | 'globals' = globalConfig ? 'globals' : 'collections'\n        const entitySlug = collectionSlug || globalConfig.slug\n        const segments = fieldPath.split('.')\n\n        let fieldAccess\n        if (versionFields) {\n          fieldAccess = policies[entityType][entitySlug]\n          if (segments[0] === 'parent' || segments[0] === 'version') {\n            segments.shift()\n          }\n        } else {\n          fieldAccess = policies[entityType][entitySlug].fields\n        }\n\n        segments.forEach((segment) => {\n          if (fieldAccess[segment]) {\n            if ('fields' in fieldAccess[segment]) {\n              fieldAccess = fieldAccess[segment].fields\n            } else if ('blocks' in fieldAccess[segment]) {\n              fieldAccess = fieldAccess[segment]\n            } else {\n              fieldAccess = fieldAccess[segment]\n            }\n          }\n        })\n\n        if (!fieldAccess?.read?.permission) {\n          errors.push({ path: fieldPath })\n        }\n      }\n\n      if (i > 1) {\n        // Remove top collection and reverse array\n        // to work backwards from top\n        const pathsToQuery = paths.slice(1).reverse()\n\n        pathsToQuery.forEach(\n          ({ collectionSlug: pathCollectionSlug, path: subPath }, pathToQueryIndex) => {\n            // On the \"deepest\" collection,\n            // validate query of the relationship\n            if (pathToQueryIndex === 0) {\n              promises.push(\n                validateQueryPaths({\n                  collectionConfig: req.payload.collections[pathCollectionSlug].config,\n                  errors,\n                  globalConfig: undefined,\n                  overrideAccess,\n                  policies,\n                  req,\n                  where: {\n                    [subPath]: {\n                      [operator]: val,\n                    },\n                  },\n                }),\n              )\n            }\n          },\n        )\n      }\n    }),\n  )\n  await Promise.all(promises)\n}\n"],"names":["fieldAffectsData","getEntityPolicies","isolateObjectProperty","getLocalizedPaths","validateQueryPaths","validateSearchParam","collectionConfig","errors","fields","globalConfig","operator","overrideAccess","path","incomingPath","policies","req","val","versionFields","sanitizedPath","replace","paths","slug","globals","type","entity","operations","collectionSlug","globalSlug","locale","payload","promises","push","map","field","invalid","i","collections","config","includes","auth","disableLocalStrategy","fieldPath","endsWith","slice","length","Array","isArray","relationTo","entityType","entitySlug","segments","split","fieldAccess","shift","forEach","segment","read","permission","pathsToQuery","reverse","pathCollectionSlug","subPath","pathToQueryIndex","undefined","where","Promise","all"],"mappings":"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"}