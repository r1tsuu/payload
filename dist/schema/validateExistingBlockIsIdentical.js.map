{"version":3,"sources":["../../src/schema/validateExistingBlockIsIdentical.ts"],"sourcesContent":["import type { Block, Field } from 'payload'\n\nimport { InvalidConfiguration } from 'payload'\nimport { fieldAffectsData, fieldHasSubFields, tabHasName } from 'payload/shared'\n\nimport type { GenericTable } from '../types.js'\n\ntype Args = {\n  block: Block\n  localized: boolean\n  rootTableName: string\n  table: GenericTable\n  tableLocales?: GenericTable\n}\n\nconst getFlattenedFieldNames = (\n  fields: Field[],\n  prefix: string = '',\n): { localized?: boolean; name: string }[] => {\n  return fields.reduce((fieldsToUse, field) => {\n    let fieldPrefix = prefix\n\n    if (\n      ['array', 'blocks', 'relationship', 'upload'].includes(field.type) ||\n      ('hasMany' in field && field.hasMany === true)\n    ) {\n      return fieldsToUse\n    }\n\n    if (fieldHasSubFields(field)) {\n      fieldPrefix = 'name' in field ? `${prefix}${field.name}_` : prefix\n      return [...fieldsToUse, ...getFlattenedFieldNames(field.fields, fieldPrefix)]\n    }\n\n    if (field.type === 'tabs') {\n      return [\n        ...fieldsToUse,\n        ...field.tabs.reduce((tabFields, tab) => {\n          fieldPrefix = 'name' in tab ? `${prefix}_${tab.name}` : prefix\n          return [\n            ...tabFields,\n            ...(tabHasName(tab)\n              ? [{ ...tab, type: 'tab' }]\n              : getFlattenedFieldNames(tab.fields, fieldPrefix)),\n          ]\n        }, []),\n      ]\n    }\n\n    if (fieldAffectsData(field)) {\n      return [\n        ...fieldsToUse,\n        {\n          name: `${fieldPrefix}${field.name}`,\n          localized: field.localized,\n        },\n      ]\n    }\n\n    return fieldsToUse\n  }, [])\n}\n\nexport const validateExistingBlockIsIdentical = ({\n  block,\n  localized,\n  rootTableName,\n  table,\n  tableLocales,\n}: Args): void => {\n  const fieldNames = getFlattenedFieldNames(block.fields)\n\n  const missingField =\n    // ensure every field from the config is in the matching table\n    fieldNames.find(({ name, localized }) => {\n      const fieldTable = localized && tableLocales ? tableLocales : table\n      return Object.keys(fieldTable).indexOf(name) === -1\n    }) ||\n    // ensure every table column is matched for every field from the config\n    Object.keys(table).find((fieldName) => {\n      if (!['_locale', '_order', '_parentID', '_path', '_uuid'].includes(fieldName)) {\n        return fieldNames.findIndex((field) => field.name) === -1\n      }\n    })\n\n  if (missingField) {\n    throw new InvalidConfiguration(\n      `The table ${rootTableName} has multiple blocks with slug ${\n        block.slug\n      }, but the schemas do not match. One block includes the field ${\n        typeof missingField === 'string' ? missingField : missingField.name\n      }, while the other block does not.`,\n    )\n  }\n\n  if (Boolean(localized) !== Boolean(table._locale)) {\n    throw new InvalidConfiguration(\n      `The table ${rootTableName} has multiple blocks with slug ${block.slug}, but the schemas do not match. One is localized, but another is not. Block schemas of the same name must match exactly.`,\n    )\n  }\n}\n"],"names":["InvalidConfiguration","fieldAffectsData","fieldHasSubFields","tabHasName","getFlattenedFieldNames","fields","prefix","reduce","fieldsToUse","field","fieldPrefix","includes","type","hasMany","name","tabs","tabFields","tab","localized","validateExistingBlockIsIdentical","block","rootTableName","table","tableLocales","fieldNames","missingField","find","fieldTable","Object","keys","indexOf","fieldName","findIndex","slug","Boolean","_locale"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ,UAAS;AAC9C,SAASC,gBAAgB,EAAEC,iBAAiB,EAAEC,UAAU,QAAQ,iBAAgB;AAYhF,MAAMC,yBAAyB,CAC7BC,QACAC,SAAiB,EAAE;IAEnB,OAAOD,OAAOE,MAAM,CAAC,CAACC,aAAaC;QACjC,IAAIC,cAAcJ;QAElB,IACE;YAAC;YAAS;YAAU;YAAgB;SAAS,CAACK,QAAQ,CAACF,MAAMG,IAAI,KAChE,aAAaH,SAASA,MAAMI,OAAO,KAAK,MACzC;YACA,OAAOL;QACT;QAEA,IAAIN,kBAAkBO,QAAQ;YAC5BC,cAAc,UAAUD,QAAQ,CAAC,EAAEH,OAAO,EAAEG,MAAMK,IAAI,CAAC,CAAC,CAAC,GAAGR;YAC5D,OAAO;mBAAIE;mBAAgBJ,uBAAuBK,MAAMJ,MAAM,EAAEK;aAAa;QAC/E;QAEA,IAAID,MAAMG,IAAI,KAAK,QAAQ;YACzB,OAAO;mBACFJ;mBACAC,MAAMM,IAAI,CAACR,MAAM,CAAC,CAACS,WAAWC;oBAC/BP,cAAc,UAAUO,MAAM,CAAC,EAAEX,OAAO,CAAC,EAAEW,IAAIH,IAAI,CAAC,CAAC,GAAGR;oBACxD,OAAO;2BACFU;2BACCb,WAAWc,OACX;4BAAC;gCAAE,GAAGA,GAAG;gCAAEL,MAAM;4BAAM;yBAAE,GACzBR,uBAAuBa,IAAIZ,MAAM,EAAEK;qBACxC;gBACH,GAAG,EAAE;aACN;QACH;QAEA,IAAIT,iBAAiBQ,QAAQ;YAC3B,OAAO;mBACFD;gBACH;oBACEM,MAAM,CAAC,EAAEJ,YAAY,EAAED,MAAMK,IAAI,CAAC,CAAC;oBACnCI,WAAWT,MAAMS,SAAS;gBAC5B;aACD;QACH;QAEA,OAAOV;IACT,GAAG,EAAE;AACP;AAEA,OAAO,MAAMW,mCAAmC,CAAC,EAC/CC,KAAK,EACLF,SAAS,EACTG,aAAa,EACbC,KAAK,EACLC,YAAY,EACP;IACL,MAAMC,aAAapB,uBAAuBgB,MAAMf,MAAM;IAEtD,MAAMoB,eACJ,8DAA8D;IAC9DD,WAAWE,IAAI,CAAC,CAAC,EAAEZ,IAAI,EAAEI,SAAS,EAAE;QAClC,MAAMS,aAAaT,aAAaK,eAAeA,eAAeD;QAC9D,OAAOM,OAAOC,IAAI,CAACF,YAAYG,OAAO,CAAChB,UAAU,CAAC;IACpD,MACA,uEAAuE;IACvEc,OAAOC,IAAI,CAACP,OAAOI,IAAI,CAAC,CAACK;QACvB,IAAI,CAAC;YAAC;YAAW;YAAU;YAAa;YAAS;SAAQ,CAACpB,QAAQ,CAACoB,YAAY;YAC7E,OAAOP,WAAWQ,SAAS,CAAC,CAACvB,QAAUA,MAAMK,IAAI,MAAM,CAAC;QAC1D;IACF;IAEF,IAAIW,cAAc;QAChB,MAAM,IAAIzB,qBACR,CAAC,UAAU,EAAEqB,cAAc,+BAA+B,EACxDD,MAAMa,IAAI,CACX,6DAA6D,EAC5D,OAAOR,iBAAiB,WAAWA,eAAeA,aAAaX,IAAI,CACpE,iCAAiC,CAAC;IAEvC;IAEA,IAAIoB,QAAQhB,eAAegB,QAAQZ,MAAMa,OAAO,GAAG;QACjD,MAAM,IAAInC,qBACR,CAAC,UAAU,EAAEqB,cAAc,+BAA+B,EAAED,MAAMa,IAAI,CAAC,wHAAwH,CAAC;IAEpM;AACF,EAAC"}