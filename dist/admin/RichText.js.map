{"version":3,"sources":["../../src/admin/RichText.ts"],"sourcesContent":["import type { GenericLanguages, I18n, I18nClient } from '@payloadcms/translations'\nimport type { JSONSchema4 } from 'json-schema'\nimport type React from 'react'\n\nimport type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FieldAffectingData, RichTextField, Validate } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { PayloadRequestWithData, RequestContext } from '../types/index.js'\nimport type { WithServerSidePropsComponentProps } from './elements/WithServerSideProps.js'\n\nexport type RichTextFieldProps<\n  Value extends object,\n  AdapterProps,\n  ExtraFieldProperties = {},\n> = Omit<RichTextField<Value, AdapterProps, ExtraFieldProperties>, 'type'> & {\n  path?: string\n}\n\nexport type AfterReadRichTextHookArgs<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  currentDepth?: number\n\n  depth?: number\n\n  draft?: boolean\n\n  fallbackLocale?: string\n\n  fieldPromises?: Promise<void>[]\n\n  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */\n  findMany?: boolean\n\n  flattenLocales?: boolean\n\n  locale?: string\n\n  /** A string relating to which operation the field type is currently executing within. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n\n  overrideAccess?: boolean\n\n  populationPromises?: Promise<void>[]\n  showHiddenFields?: boolean\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\nexport type AfterChangeRichTextHookArgs<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  /** A string relating to which operation the field type is currently executing within. */\n  operation: 'create' | 'update'\n  /** The document before changes were applied. */\n  previousDoc?: TData\n  /** The sibling data of the document before changes being applied. */\n  previousSiblingDoc?: TData\n  /** The previous value of the field, before changes */\n  previousValue?: TValue\n}\nexport type BeforeValidateRichTextHookArgs<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  /** A string relating to which operation the field type is currently executing within. */\n  operation: 'create' | 'update'\n  overrideAccess?: boolean\n  /** The sibling data of the document before changes being applied. */\n  previousSiblingDoc?: TData\n  /** The previous value of the field, before changes */\n  previousValue?: TValue\n}\n\nexport type BeforeChangeRichTextHookArgs<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  /**\n   * The original data with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.\n   */\n  docWithLocales?: Record<string, unknown>\n\n  duplicate?: boolean\n\n  errors?: { field: string; message: string }[]\n  /** Only available in `beforeChange` field hooks */\n  mergeLocaleActions?: (() => Promise<void>)[]\n  /** A string relating to which operation the field type is currently executing within. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n  /** The sibling data of the document before changes being applied. */\n  previousSiblingDoc?: TData\n  /** The previous value of the field, before changes */\n  previousValue?: TValue\n  /**\n   * The original siblingData with locales (not modified by any hooks).\n   */\n  siblingDocWithLocales?: Record<string, unknown>\n\n  skipValidation?: boolean\n}\n\nexport type BaseRichTextHookArgs<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */\n  collection: SanitizedCollectionConfig | null\n  context: RequestContext\n  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */\n  data?: Partial<TData>\n  /** The field which the hook is running against. */\n  field: FieldAffectingData\n  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */\n  global: SanitizedGlobalConfig | null\n\n  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */\n  originalDoc?: TData\n  /**\n   * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n   */\n  path: (number | string)[]\n\n  /** The Express request object. It is mocked for Local API operations. */\n  req: PayloadRequestWithData\n  /**\n   * The schemaPath of the field, e.g. [\"group\", \"myArray\", \"textField\"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.\n   */\n  schemaPath: string[]\n  /** The sibling data passed to a field that the hook is running against. */\n  siblingData: Partial<TSiblingData>\n  /** The value of the field. */\n  value?: TValue\n}\n\nexport type AfterReadRichTextHook<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = (\n  args: BaseRichTextHookArgs<TData, TValue, TSiblingData> &\n    AfterReadRichTextHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type AfterChangeRichTextHook<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = (\n  args: BaseRichTextHookArgs<TData, TValue, TSiblingData> &\n    AfterChangeRichTextHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type BeforeChangeRichTextHook<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = (\n  args: BaseRichTextHookArgs<TData, TValue, TSiblingData> &\n    BeforeChangeRichTextHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type BeforeValidateRichTextHook<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = (\n  args: BaseRichTextHookArgs<TData, TValue, TSiblingData> &\n    BeforeValidateRichTextHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type RichTextHooks = {\n  afterChange?: AfterChangeRichTextHook[]\n  afterRead?: AfterReadRichTextHook[]\n  beforeChange?: BeforeChangeRichTextHook[]\n  beforeValidate?: BeforeValidateRichTextHook[]\n}\n\ntype RichTextAdapterBase<\n  Value extends object = object,\n  AdapterProps = any,\n  ExtraFieldProperties = {},\n> = {\n  generateComponentMap: (args: {\n    WithServerSideProps: React.FC<Omit<WithServerSidePropsComponentProps, 'serverOnlyProps'>>\n    config: SanitizedConfig\n    i18n: I18nClient\n    schemaPath: string\n  }) => Map<string, React.ReactNode>\n  generateSchemaMap?: (args: {\n    config: SanitizedConfig\n    i18n: I18n<any, any>\n    schemaMap: Map<string, Field[]>\n    schemaPath: string\n  }) => Map<string, Field[]>\n  /**\n   * Like an afterRead hook, but runs only for the GraphQL resolver. For populating data, this should be used, as afterRead hooks do not have a depth in graphQL.\n   *\n   * To populate stuff / resolve field hooks, mutate the incoming populationPromises or fieldPromises array. They will then be awaited in the correct order within payload itself.\n   * @param data\n   */\n  graphQLPopulationPromises?: (data: {\n    context: RequestContext\n    currentDepth?: number\n    depth: number\n    draft: boolean\n    field: RichTextField<Value, AdapterProps, ExtraFieldProperties>\n    fieldPromises: Promise<void>[]\n    findMany: boolean\n    flattenLocales: boolean\n    overrideAccess?: boolean\n    populationPromises: Promise<void>[]\n    req: PayloadRequestWithData\n    showHiddenFields: boolean\n    siblingDoc: Record<string, unknown>\n  }) => void\n  hooks?: RichTextHooks\n  i18n?: Partial<GenericLanguages>\n  outputSchema?: ({\n    collectionIDFieldTypes,\n    config,\n    field,\n    interfaceNameDefinitions,\n    isRequired,\n  }: {\n    collectionIDFieldTypes: { [key: string]: 'number' | 'string' }\n    config?: SanitizedConfig\n    field: RichTextField<Value, AdapterProps, ExtraFieldProperties>\n    /**\n     * Allows you to define new top-level interfaces that can be re-used in the output schema.\n     */\n    interfaceNameDefinitions: Map<string, JSONSchema4>\n    isRequired: boolean\n  }) => JSONSchema4\n  validate: Validate<\n    Value,\n    Value,\n    unknown,\n    RichTextField<Value, AdapterProps, ExtraFieldProperties>\n  >\n}\n\nexport type RichTextAdapter<\n  Value extends object = object,\n  AdapterProps = any,\n  ExtraFieldProperties = {},\n> = RichTextAdapterBase<Value, AdapterProps, ExtraFieldProperties> & {\n  CellComponent: React.FC<any>\n  FieldComponent: React.FC<RichTextFieldProps<Value, AdapterProps, ExtraFieldProperties>>\n}\n\nexport type RichTextAdapterProvider<\n  Value extends object = object,\n  AdapterProps = any,\n  ExtraFieldProperties = {},\n> = ({\n  config,\n  isRoot,\n}: {\n  config: SanitizedConfig\n  /**\n   * Whether or not this is the root richText editor, defined in the payload.config.ts.\n   *\n   * @default false\n   */\n  isRoot?: boolean\n}) =>\n  | Promise<RichTextAdapter<Value, AdapterProps, ExtraFieldProperties>>\n  | RichTextAdapter<Value, AdapterProps, ExtraFieldProperties>\n"],"names":[],"mappings":"AAmQA,WAiB8D"}