{"version":3,"sources":["../../src/utilities/getEntityPolicies.ts"],"sourcesContent":["import type { CollectionPermission, GlobalPermission } from '../auth/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { Access } from '../config/types.js'\nimport type { FieldAccess } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { AllOperations, Document, PayloadRequestWithData, Where } from '../types/index.js'\n\nimport { tabHasName } from '../fields/config/types.js'\n\ntype Args = {\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n  id?: number | string\n  operations: AllOperations[]\n  req: PayloadRequestWithData\n  type: 'collection' | 'global'\n}\n\ntype ReturnType<T extends Args> = T['type'] extends 'global'\n  ? GlobalPermission\n  : CollectionPermission\n\ntype CreateAccessPromise = (args: {\n  access: Access | FieldAccess\n  accessLevel: 'entity' | 'field'\n  disableWhere?: boolean\n  operation: AllOperations\n  policiesObj: {\n    [key: string]: any\n  }\n}) => Promise<void>\n\nexport async function getEntityPolicies<T extends Args>(args: T): Promise<ReturnType<T>> {\n  const { id, type, entity, operations, req } = args\n  const { data, payload, user } = req\n  const isLoggedIn = !!user\n\n  const policies = {\n    fields: {},\n  } as ReturnType<T>\n\n  let docBeingAccessed\n\n  async function getEntityDoc({ where }: { where?: Where } = {}): Promise<TypeWithID & Document> {\n    if (entity.slug) {\n      if (type === 'global') {\n        return payload.findGlobal({\n          slug: entity.slug,\n          overrideAccess: true,\n          req,\n        })\n      }\n\n      if (type === 'collection' && id) {\n        if (typeof where === 'object') {\n          const paginatedRes = await payload.find({\n            collection: entity.slug,\n            depth: 0,\n            limit: 1,\n            overrideAccess: true,\n            pagination: false,\n            req,\n            where: {\n              ...where,\n              and: [\n                ...(where.and || []),\n                {\n                  id: {\n                    equals: id,\n                  },\n                },\n              ],\n            },\n          })\n\n          return paginatedRes?.docs?.[0] || undefined\n        }\n\n        return payload.findByID({\n          id,\n          collection: entity.slug,\n          depth: 0,\n          overrideAccess: true,\n          req,\n        })\n      }\n    }\n\n    return undefined\n  }\n\n  const createAccessPromise: CreateAccessPromise = async ({\n    access,\n    accessLevel,\n    disableWhere = false,\n    operation,\n    policiesObj,\n  }) => {\n    const mutablePolicies = policiesObj\n\n    if (accessLevel === 'field' && docBeingAccessed === undefined) {\n      // assign docBeingAccessed first as the promise to avoid multiple calls to getEntityDoc\n      docBeingAccessed = getEntityDoc().then((doc) => {\n        docBeingAccessed = doc\n      })\n    }\n    // awaiting the promise to ensure docBeingAccessed is assigned before it is used\n    await docBeingAccessed\n\n    // https://payloadcms.slack.com/archives/C048Z9C2BEX/p1702054928343769\n    const accessResult = await access({ id, data, doc: docBeingAccessed, req })\n\n    if (typeof accessResult === 'object' && !disableWhere) {\n      mutablePolicies[operation] = {\n        permission:\n          id || type === 'global' ? !!(await getEntityDoc({ where: accessResult })) : true,\n        where: accessResult,\n      }\n    } else if (mutablePolicies[operation]?.permission !== false) {\n      mutablePolicies[operation] = {\n        permission: !!accessResult,\n      }\n    }\n  }\n\n  const executeFieldPolicies = async ({ entityPermission, fields, operation, policiesObj }) => {\n    const mutablePolicies = policiesObj.fields\n\n    await Promise.all(\n      fields.map(async (field) => {\n        if (field.name) {\n          if (!mutablePolicies[field.name]) mutablePolicies[field.name] = {}\n\n          if (field.access && typeof field.access[operation] === 'function') {\n            await createAccessPromise({\n              access: field.access[operation],\n              accessLevel: 'field',\n              disableWhere: true,\n              operation,\n              policiesObj: mutablePolicies[field.name],\n            })\n          } else {\n            mutablePolicies[field.name][operation] = {\n              permission: policiesObj[operation]?.permission,\n            }\n          }\n\n          if (field.fields) {\n            if (!mutablePolicies[field.name].fields) mutablePolicies[field.name].fields = {}\n\n            await executeFieldPolicies({\n              entityPermission,\n              fields: field.fields,\n              operation,\n              policiesObj: mutablePolicies[field.name],\n            })\n          }\n\n          if (field?.blocks) {\n            if (!mutablePolicies[field.name]?.blocks) mutablePolicies[field.name].blocks = {}\n\n            await Promise.all(\n              field.blocks.map(async (block) => {\n                if (!mutablePolicies[field.name].blocks?.[block.slug]) {\n                  mutablePolicies[field.name].blocks[block.slug] = {\n                    fields: {},\n                    [operation]: { permission: entityPermission },\n                  }\n                } else if (!mutablePolicies[field.name].blocks[block.slug][operation]) {\n                  mutablePolicies[field.name].blocks[block.slug][operation] = {\n                    permission: entityPermission,\n                  }\n                }\n\n                await executeFieldPolicies({\n                  entityPermission,\n                  fields: block.fields,\n                  operation,\n                  policiesObj: mutablePolicies[field.name].blocks[block.slug],\n                })\n              }),\n            )\n          }\n        } else if (field.fields) {\n          await executeFieldPolicies({\n            entityPermission,\n            fields: field.fields,\n            operation,\n            policiesObj,\n          })\n        } else if (field.type === 'tabs') {\n          await Promise.all(\n            field.tabs.map(async (tab) => {\n              if (tabHasName(tab)) {\n                if (!mutablePolicies[tab.name]) {\n                  mutablePolicies[tab.name] = {\n                    fields: {},\n                    [operation]: { permission: entityPermission },\n                  }\n                } else if (!mutablePolicies[tab.name][operation]) {\n                  mutablePolicies[tab.name][operation] = { permission: entityPermission }\n                }\n                await executeFieldPolicies({\n                  entityPermission,\n                  fields: tab.fields,\n                  operation,\n                  policiesObj: mutablePolicies[tab.name],\n                })\n              } else {\n                await executeFieldPolicies({\n                  entityPermission,\n                  fields: tab.fields,\n                  operation,\n                  policiesObj,\n                })\n              }\n            }),\n          )\n        }\n      }),\n    )\n  }\n\n  await operations.reduce(async (priorOperation, operation) => {\n    await priorOperation\n\n    let entityAccessPromise: Promise<void>\n\n    if (typeof entity.access[operation] === 'function') {\n      entityAccessPromise = createAccessPromise({\n        access: entity.access[operation],\n        accessLevel: 'entity',\n        operation,\n        policiesObj: policies,\n      })\n    } else {\n      policies[operation] = {\n        permission: isLoggedIn,\n      }\n    }\n\n    await entityAccessPromise\n\n    await executeFieldPolicies({\n      entityPermission: policies[operation].permission,\n      fields: entity.fields,\n      operation,\n      policiesObj: policies,\n    })\n  }, Promise.resolve())\n\n  return policies\n}\n"],"names":["tabHasName","getEntityPolicies","args","id","type","entity","operations","req","data","payload","user","isLoggedIn","policies","fields","docBeingAccessed","getEntityDoc","where","slug","findGlobal","overrideAccess","paginatedRes","find","collection","depth","limit","pagination","and","equals","docs","undefined","findByID","createAccessPromise","access","accessLevel","disableWhere","operation","policiesObj","mutablePolicies","then","doc","accessResult","permission","executeFieldPolicies","entityPermission","Promise","all","map","field","name","blocks","block","tabs","tab","reduce","priorOperation","entityAccessPromise","resolve"],"mappings":"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"}