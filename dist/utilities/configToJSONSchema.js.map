{"version":3,"sources":["../../src/utilities/configToJSONSchema.ts"],"sourcesContent":["import type { JSONSchema4, JSONSchema4TypeName } from 'json-schema'\n\nimport pluralize from 'pluralize'\nconst { singular } = pluralize\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FieldAffectingData, Option } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { MissingEditorProp } from '../errors/MissingEditorProp.js'\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\nimport { deepCopyObject } from './deepCopyObject.js'\nimport { toWords } from './formatLabels.js'\nimport { getCollectionIDFieldTypes } from './getCollectionIDFieldTypes.js'\n\nconst fieldIsRequired = (field: Field) => {\n  const isConditional = Boolean(field?.admin && field?.admin?.condition)\n  if (isConditional) return false\n\n  const isMarkedRequired = 'required' in field && field.required === true\n  if (fieldAffectsData(field) && isMarkedRequired) return true\n\n  // if any subfields are required, this field is required\n  if ('fields' in field && field.type !== 'array') {\n    return field.fields.some((subField) => fieldIsRequired(subField))\n  }\n\n  // if any tab subfields have required fields, this field is required\n  if (field.type === 'tabs') {\n    return field.tabs.some((tab) => {\n      if ('name' in tab) {\n        return tab.fields.some((subField) => fieldIsRequired(subField))\n      }\n      return false\n    })\n  }\n\n  return false\n}\n\nfunction buildOptionEnums(options: Option[]): string[] {\n  return options.map((option) => {\n    if (typeof option === 'object' && 'value' in option) {\n      return option.value\n    }\n\n    return option\n  })\n}\n\nfunction generateEntitySchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce((acc, { slug }) => {\n    acc[slug] = {\n      $ref: `#/definitions/${slug}`,\n    }\n\n    return acc\n  }, {})\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateLocaleEntitySchemas(localization: SanitizedConfig['localization']): JSONSchema4 {\n  if (localization && 'locales' in localization && localization?.locales) {\n    const localesFromConfig = localization?.locales\n\n    const locales = [...localesFromConfig].map((locale) => {\n      return locale.code\n    }, [])\n\n    return {\n      type: 'string',\n      enum: locales,\n    }\n  }\n\n  return {\n    type: 'null',\n  }\n}\n\nfunction generateAuthEntitySchemas(entities: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties: JSONSchema4[] = [...entities]\n    .filter(({ auth }) => Boolean(auth))\n    .map(({ slug }) => {\n      return {\n        allOf: [\n          { $ref: `#/definitions/${slug}` },\n          {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              collection: { type: 'string', enum: [slug] },\n            },\n            required: ['collection'],\n          },\n        ],\n      }\n    }, {})\n\n  return {\n    oneOf: properties,\n  }\n}\n\n/**\n * Returns a JSON Schema Type with 'null' added if the field is not required.\n */\nexport function withNullableJSONSchemaType(\n  fieldType: JSONSchema4TypeName,\n  isRequired: boolean,\n): JSONSchema4TypeName | JSONSchema4TypeName[] {\n  const fieldTypes = [fieldType]\n  if (isRequired) return fieldType\n  fieldTypes.push('null')\n  return fieldTypes\n}\n\nexport function fieldsToJSONSchema(\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  fields: Field[],\n  /**\n   * Allows you to define new top-level interfaces that can be re-used in the output schema.\n   */\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  config?: SanitizedConfig,\n): {\n  properties: {\n    [k: string]: JSONSchema4\n  }\n  required: string[]\n} {\n  const requiredFieldNames = new Set<string>()\n\n  return {\n    properties: Object.fromEntries(\n      fields.reduce((fieldSchemas, field) => {\n        const isRequired = fieldAffectsData(field) && fieldIsRequired(field)\n        if (isRequired) requiredFieldNames.add(field.name)\n\n        let fieldSchema: JSONSchema4\n\n        if ('typescriptSchema' in field && field.typescriptSchema) {\n          fieldSchema = field.typescriptSchema\n        } else {\n          switch (field.type) {\n            case 'text':\n              if (field.hasMany === true) {\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: { type: 'string' },\n                }\n              } else {\n                fieldSchema = { type: withNullableJSONSchemaType('string', isRequired) }\n              }\n              break\n            case 'textarea':\n            case 'code':\n            case 'email':\n            case 'date': {\n              fieldSchema = { type: withNullableJSONSchemaType('string', isRequired) }\n              break\n            }\n\n            case 'number': {\n              if (field.hasMany === true) {\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: { type: 'number' },\n                }\n              } else {\n                fieldSchema = { type: withNullableJSONSchemaType('number', isRequired) }\n              }\n              break\n            }\n\n            case 'checkbox': {\n              fieldSchema = { type: withNullableJSONSchemaType('boolean', isRequired) }\n              break\n            }\n\n            case 'json': {\n              fieldSchema = field.jsonSchema?.schema || {\n                type: ['object', 'array', 'string', 'number', 'boolean', 'null'],\n              }\n              break\n            }\n\n            case 'richText': {\n              if (!field?.editor) {\n                throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n              }\n              if (typeof field.editor === 'function') {\n                throw new Error('Attempted to access unsanitized rich text editor.')\n              }\n              if (field.editor.outputSchema) {\n                fieldSchema = field.editor.outputSchema({\n                  collectionIDFieldTypes,\n                  config,\n                  field,\n                  interfaceNameDefinitions,\n                  isRequired,\n                })\n              } else {\n                // Maintain backwards compatibility with existing rich text editors\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    type: 'object',\n                  },\n                }\n              }\n\n              break\n            }\n\n            case 'radio': {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('string', isRequired),\n                enum: buildOptionEnums(field.options),\n              }\n\n              break\n            }\n\n            case 'select': {\n              const optionEnums = buildOptionEnums(field.options)\n\n              if (field.hasMany) {\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    type: 'string',\n                    enum: optionEnums,\n                  },\n                }\n              } else {\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('string', isRequired),\n                  enum: optionEnums,\n                }\n              }\n\n              break\n            }\n\n            case 'point': {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: [\n                  {\n                    type: 'number',\n                  },\n                  {\n                    type: 'number',\n                  },\n                ],\n                maxItems: 2,\n                minItems: 2,\n              }\n              break\n            }\n\n            case 'relationship': {\n              if (Array.isArray(field.relationTo)) {\n                if (field.hasMany) {\n                  fieldSchema = {\n                    type: withNullableJSONSchemaType('array', isRequired),\n                    items: {\n                      oneOf: field.relationTo.map((relation) => {\n                        return {\n                          type: 'object',\n                          additionalProperties: false,\n                          properties: {\n                            relationTo: {\n                              const: relation,\n                            },\n                            value: {\n                              oneOf: [\n                                {\n                                  type: collectionIDFieldTypes[relation],\n                                },\n                                {\n                                  $ref: `#/definitions/${relation}`,\n                                },\n                              ],\n                            },\n                          },\n                          required: ['value', 'relationTo'],\n                        }\n                      }),\n                    },\n                  }\n                } else {\n                  fieldSchema = {\n                    oneOf: field.relationTo.map((relation) => {\n                      return {\n                        type: withNullableJSONSchemaType('object', isRequired),\n                        additionalProperties: false,\n                        properties: {\n                          relationTo: {\n                            const: relation,\n                          },\n                          value: {\n                            oneOf: [\n                              {\n                                type: collectionIDFieldTypes[relation],\n                              },\n                              {\n                                $ref: `#/definitions/${relation}`,\n                              },\n                            ],\n                          },\n                        },\n                        required: ['value', 'relationTo'],\n                      }\n                    }),\n                  }\n                }\n              } else if (field.hasMany) {\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    oneOf: [\n                      {\n                        type: collectionIDFieldTypes[field.relationTo],\n                      },\n                      {\n                        $ref: `#/definitions/${field.relationTo}`,\n                      },\n                    ],\n                  },\n                }\n              } else {\n                fieldSchema = {\n                  oneOf: [\n                    {\n                      type: withNullableJSONSchemaType(\n                        collectionIDFieldTypes[field.relationTo],\n                        isRequired,\n                      ),\n                    },\n                    {\n                      $ref: `#/definitions/${field.relationTo}`,\n                    },\n                  ],\n                }\n              }\n\n              break\n            }\n\n            case 'upload': {\n              fieldSchema = {\n                oneOf: [\n                  {\n                    type: collectionIDFieldTypes[field.relationTo],\n                  },\n                  {\n                    $ref: `#/definitions/${field.relationTo}`,\n                  },\n                ],\n              }\n              if (!isRequired) fieldSchema.oneOf.push({ type: 'null' })\n              break\n            }\n\n            case 'blocks': {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  oneOf: field.blocks.map((block) => {\n                    const blockFieldSchemas = fieldsToJSONSchema(\n                      collectionIDFieldTypes,\n                      block.fields,\n                      interfaceNameDefinitions,\n                      config,\n                    )\n\n                    const blockSchema: JSONSchema4 = {\n                      type: 'object',\n                      additionalProperties: false,\n                      properties: {\n                        ...blockFieldSchemas.properties,\n                        blockType: {\n                          const: block.slug,\n                        },\n                      },\n                      required: ['blockType', ...blockFieldSchemas.required],\n                    }\n\n                    if (block.interfaceName) {\n                      interfaceNameDefinitions.set(block.interfaceName, blockSchema)\n\n                      return {\n                        $ref: `#/definitions/${block.interfaceName}`,\n                      }\n                    }\n\n                    return blockSchema\n                  }),\n                },\n              }\n              break\n            }\n\n            case 'array': {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'object',\n                  additionalProperties: false,\n                  ...fieldsToJSONSchema(\n                    collectionIDFieldTypes,\n                    field.fields,\n                    interfaceNameDefinitions,\n                    config,\n                  ),\n                },\n              }\n\n              if (field.interfaceName) {\n                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n                fieldSchema = {\n                  $ref: `#/definitions/${field.interfaceName}`,\n                }\n              }\n              break\n            }\n\n            case 'row':\n            case 'collapsible': {\n              const childSchema = fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                field.fields,\n                interfaceNameDefinitions,\n                config,\n              )\n              Object.entries(childSchema.properties).forEach(([propName, propSchema]) => {\n                fieldSchemas.set(propName, propSchema)\n              })\n              childSchema.required.forEach((propName) => {\n                requiredFieldNames.add(propName)\n              })\n              break\n            }\n\n            case 'tabs': {\n              field.tabs.forEach((tab) => {\n                const childSchema = fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  tab.fields,\n                  interfaceNameDefinitions,\n                  config,\n                )\n                if (tabHasName(tab)) {\n                  // could have interface\n                  fieldSchemas.set(tab.name, {\n                    type: 'object',\n                    additionalProperties: false,\n                    ...childSchema,\n                  })\n\n                  // If the named tab has any required fields then we mark this as required otherwise it should be optional\n                  const hasRequiredFields = tab.fields.some((subField) => fieldIsRequired(subField))\n\n                  if (hasRequiredFields) {\n                    requiredFieldNames.add(tab.name)\n                  }\n                } else {\n                  Object.entries(childSchema.properties).forEach(([propName, propSchema]) => {\n                    fieldSchemas.set(propName, propSchema)\n                  })\n                  childSchema.required.forEach((propName) => {\n                    requiredFieldNames.add(propName)\n                  })\n                }\n              })\n              break\n            }\n\n            case 'group': {\n              fieldSchema = {\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.fields,\n                  interfaceNameDefinitions,\n                  config,\n                ),\n              }\n\n              if (field.interfaceName) {\n                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n                fieldSchema = {\n                  $ref: `#/definitions/${field.interfaceName}`,\n                }\n              }\n              break\n            }\n\n            default: {\n              break\n            }\n          }\n        }\n\n        if (fieldSchema && fieldAffectsData(field)) {\n          fieldSchemas.set(field.name, fieldSchema)\n        }\n\n        return fieldSchemas\n      }, new Map<string, JSONSchema4>()),\n    ),\n    required: Array.from(requiredFieldNames),\n  }\n}\n\n// This function is part of the public API and is exported through payload/utilities\nexport function entityToJSONSchema(\n  config: SanitizedConfig,\n  incomingEntity: SanitizedCollectionConfig | SanitizedGlobalConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  defaultIDType: 'number' | 'text',\n): JSONSchema4 {\n  const entity: SanitizedCollectionConfig | SanitizedGlobalConfig = deepCopyObject(incomingEntity)\n  const title = entity.typescript?.interface\n    ? entity.typescript.interface\n    : singular(toWords(entity.slug, true))\n\n  const idField: FieldAffectingData = { name: 'id', type: defaultIDType as 'text', required: true }\n  const customIdField = entity.fields.find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  ) as FieldAffectingData\n\n  if (customIdField && customIdField.type !== 'group' && customIdField.type !== 'tab') {\n    customIdField.required = true\n  } else {\n    entity.fields.unshift(idField)\n  }\n\n  // mark timestamp fields required\n  if ('timestamps' in entity && entity.timestamps !== false) {\n    entity.fields = entity.fields.map((field) => {\n      if (fieldAffectsData(field) && (field.name === 'createdAt' || field.name === 'updatedAt')) {\n        return {\n          ...field,\n          required: true,\n        }\n      }\n      return field\n    })\n  }\n\n  if ('auth' in entity && entity.auth && !entity.auth?.disableLocalStrategy) {\n    entity.fields.push({\n      name: 'password',\n      type: 'text',\n    })\n  }\n\n  //  Used for relationship fields, to determine whether to use a string or number type for the ID.\n  const collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    title,\n    ...fieldsToJSONSchema(collectionIDFieldTypes, entity.fields, interfaceNameDefinitions, config),\n  }\n}\n\n/**\n * This is used for generating the TypeScript types (payload-types.ts) with the payload generate:types command.\n */\nexport function configToJSONSchema(\n  config: SanitizedConfig,\n  defaultIDType?: 'number' | 'text',\n): JSONSchema4 {\n  // a mutable Map to store custom top-level `interfaceName` types. Fields with an `interfaceName` property will be moved to the top-level definitions here\n  const interfaceNameDefinitions: Map<string, JSONSchema4> = new Map()\n\n  // Collections and Globals have to be moved to the top-level definitions as well. Reason: The top-level type will be the `Config` type - we don't want all collection and global\n  // types to be inlined inside the `Config` type\n  const entityDefinitions: { [k: string]: JSONSchema4 } = [\n    ...config.globals,\n    ...config.collections,\n  ].reduce((acc, entity) => {\n    acc[entity.slug] = entityToJSONSchema(config, entity, interfaceNameDefinitions, defaultIDType)\n    return acc\n  }, {})\n\n  return {\n    additionalProperties: false,\n    definitions: {\n      ...entityDefinitions,\n      ...Object.fromEntries(interfaceNameDefinitions),\n      ...config.typescript.definitions,\n    },\n    // These properties here will be very simple, as all the complexity is in the definitions. These are just the properties for the top-level `Config` type\n    type: 'object',\n    properties: {\n      collections: generateEntitySchemas(config.collections || []),\n      globals: generateEntitySchemas(config.globals || []),\n      locale: generateLocaleEntitySchemas(config.localization),\n      user: generateAuthEntitySchemas(config.collections),\n    },\n    required: ['user', 'locale', 'collections', 'globals'],\n    title: 'Config',\n  }\n}\n"],"names":["pluralize","singular","MissingEditorProp","fieldAffectsData","tabHasName","deepCopyObject","toWords","getCollectionIDFieldTypes","fieldIsRequired","field","isConditional","Boolean","admin","condition","isMarkedRequired","required","type","fields","some","subField","tabs","tab","buildOptionEnums","options","map","option","value","generateEntitySchemas","entities","properties","reduce","acc","slug","$ref","additionalProperties","Object","keys","generateLocaleEntitySchemas","localization","locales","localesFromConfig","locale","code","enum","generateAuthEntitySchemas","filter","auth","allOf","collection","oneOf","withNullableJSONSchemaType","fieldType","isRequired","fieldTypes","push","fieldsToJSONSchema","collectionIDFieldTypes","interfaceNameDefinitions","config","requiredFieldNames","Set","fromEntries","fieldSchemas","add","name","fieldSchema","typescriptSchema","hasMany","items","jsonSchema","schema","editor","Error","outputSchema","optionEnums","maxItems","minItems","Array","isArray","relationTo","relation","const","blocks","block","blockFieldSchemas","blockSchema","blockType","interfaceName","set","childSchema","entries","forEach","propName","propSchema","hasRequiredFields","Map","from","entityToJSONSchema","incomingEntity","defaultIDType","entity","title","typescript","interface","idField","customIdField","find","unshift","timestamps","disableLocalStrategy","configToJSONSchema","entityDefinitions","globals","collections","definitions","user"],"mappings":"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"}