{"version":3,"sources":["../../src/utilities/importWithoutClientFiles.ts"],"sourcesContent":["import { register } from 'node:module'\nimport { URL, fileURLToPath, pathToFileURL } from 'node:url'\nimport path from 'path'\n\nimport type { SanitizedConfig } from '../config/types.js'\n\nimport { loadEnv } from '../bin/loadEnv.js'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nexport const importWithoutClientFiles = async <T = unknown>(filePath: string) => {\n  const { href: filePathUrl } = pathToFileURL(filePath)\n  const { href: loaderUrl } = pathToFileURL(path.resolve(dirname, '../../dist/bin/loader/index.js'))\n\n  register(loaderUrl, filePathUrl)\n  const result = await import(filePath)\n  return result as T\n}\n\n/**\n * Resolve and load Payload config from either a relative or absolute path\n */\nexport const importConfig = async (configPath: string) => {\n  loadEnv() // loadConfig would usually be run outside of next. This means they will not get next's automatic env loading here. In order to not force them to install dotenv and set it up manually, we can load the env for them here\n  const isAbsolutePath = path.isAbsolute(configPath)\n  if (isAbsolutePath) {\n    const config = await importWithoutClientFiles<{ default: Promise<SanitizedConfig> }>(configPath)\n    return await config.default\n  }\n\n  const callerFilename = getCallerInfo()[1].getFileName()\n\n  const url = new URL(callerFilename)\n\n  const callerDir = path.dirname(fileURLToPath(url))\n\n  const fullConfigPath = path.resolve(callerDir, configPath)\n\n  const config = await importWithoutClientFiles<{ default: Promise<SanitizedConfig> }>(\n    fullConfigPath,\n  )\n  return await config.default\n}\n\nconst getCallerInfo = () => {\n  const _prepareStackTrace = Error.prepareStackTrace\n  try {\n    let result = []\n    Error.prepareStackTrace = (_, callSites) => {\n      const callSitesWithoutCurrent = callSites.slice(1)\n      result = callSitesWithoutCurrent\n      return callSitesWithoutCurrent\n    }\n\n    new Error().stack\n    return result\n  } finally {\n    Error.prepareStackTrace = _prepareStackTrace\n  }\n}\n"],"names":["register","URL","fileURLToPath","pathToFileURL","path","loadEnv","filename","url","dirname","importWithoutClientFiles","filePath","href","filePathUrl","loaderUrl","resolve","result","importConfig","configPath","isAbsolutePath","isAbsolute","config","default","callerFilename","getCallerInfo","getFileName","callerDir","fullConfigPath","_prepareStackTrace","Error","prepareStackTrace","_","callSites","callSitesWithoutCurrent","slice","stack"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,cAAa;AACtC,SAASC,GAAG,EAAEC,aAAa,EAAEC,aAAa,QAAQ,WAAU;AAC5D,OAAOC,UAAU,OAAM;AAIvB,SAASC,OAAO,QAAQ,oBAAmB;AAE3C,MAAMC,WAAWJ,cAAc,YAAYK,GAAG;AAC9C,MAAMC,UAAUJ,KAAKI,OAAO,CAACF;AAE7B,OAAO,MAAMG,2BAA2B,OAAoBC;IAC1D,MAAM,EAAEC,MAAMC,WAAW,EAAE,GAAGT,cAAcO;IAC5C,MAAM,EAAEC,MAAME,SAAS,EAAE,GAAGV,cAAcC,KAAKU,OAAO,CAACN,SAAS;IAEhER,SAASa,WAAWD;IACpB,MAAMG,SAAS,MAAM,MAAM,CAACL;IAC5B,OAAOK;AACT,EAAC;AAED;;CAEC,GACD,OAAO,MAAMC,eAAe,OAAOC;IACjCZ,UAAU,0NAA0N;;IACpO,MAAMa,iBAAiBd,KAAKe,UAAU,CAACF;IACvC,IAAIC,gBAAgB;QAClB,MAAME,SAAS,MAAMX,yBAAgEQ;QACrF,OAAO,MAAMG,OAAOC,OAAO;IAC7B;IAEA,MAAMC,iBAAiBC,eAAe,CAAC,EAAE,CAACC,WAAW;IAErD,MAAMjB,MAAM,IAAIN,IAAIqB;IAEpB,MAAMG,YAAYrB,KAAKI,OAAO,CAACN,cAAcK;IAE7C,MAAMmB,iBAAiBtB,KAAKU,OAAO,CAACW,WAAWR;IAE/C,MAAMG,SAAS,MAAMX,yBACnBiB;IAEF,OAAO,MAAMN,OAAOC,OAAO;AAC7B,EAAC;AAED,MAAME,gBAAgB;IACpB,MAAMI,qBAAqBC,MAAMC,iBAAiB;IAClD,IAAI;QACF,IAAId,SAAS,EAAE;QACfa,MAAMC,iBAAiB,GAAG,CAACC,GAAGC;YAC5B,MAAMC,0BAA0BD,UAAUE,KAAK,CAAC;YAChDlB,SAASiB;YACT,OAAOA;QACT;QAEA,IAAIJ,QAAQM,KAAK;QACjB,OAAOnB;IACT,SAAU;QACRa,MAAMC,iBAAiB,GAAGF;IAC5B;AACF"}