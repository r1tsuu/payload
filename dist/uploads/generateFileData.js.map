{"version":3,"sources":["../../src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs'\nimport mkdirp from 'mkdirp'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequestWithData } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, MissingFile } from '../errors/index.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { resizeAndTransformImageSizes } from './imageResizer.js'\nimport { isImage } from './isImage.js'\n\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequestWithData\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  if (!file && uploadEdits && data) {\n    const { filename, url } = data as FileData\n\n    try {\n      if (url && url.startsWith('/') && !disableLocalStorage) {\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        file = await getExternalFile({\n          data: data as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) throw new MissingFile(req.t)\n\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  if (!disableLocalStorage) {\n    mkdirp.sync(staticPath)\n  }\n\n  let newData = data\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(resizeOptions || formatOptions || imageSizes || trimOptions || file.tempFilePath)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) sharpOptions.animated = true\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = await fileTypeFromBuffer(fileBuffer.data)) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop()\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') mime = 'image/svg+xml'\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        req,\n        staticPath,\n      })\n    }\n\n    fileData.filename = fsSafeName\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({ cropData, dimensions, file, sharp })\n\n      filesToSave.push({\n        buffer: croppedImage,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      fileForResize = {\n        ...file,\n        data: croppedImage,\n        size: info.size,\n      }\n      fileData.width = info.width\n      fileData.height = info.height\n      if (fileIsAnimatedType) {\n        const metadata = await sharpFile.metadata()\n        fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n      }\n      fileData.filesize = info.size\n\n      if (file.tempFilePath) {\n        await fs.promises.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.promises.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      const { focalPoint, sizeData, sizesToSave } = await resizeAndTransformImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions\n          : {\n              ...dimensions,\n              height: fileData.height,\n              width: fileData.width,\n            },\n        file: fileForResize,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath,\n        uploadEdits,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequestWithData\n}): UploadEdits {\n  const { data, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const {\n    uploadEdits = {},\n  }: {\n    uploadEdits?: UploadEdits\n  } = req.query || {}\n\n  if (uploadEdits.focalPoint) return uploadEdits\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  // If no change in focal point, return undefined.\n  // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n  if (origDoc && incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n    return undefined\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","mkdirp","sanitize","FileRetrievalError","FileUploadError","MissingFile","canResizeImage","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","resizeAndTransformImageSizes","isImage","generateFileData","collection","config","collectionConfig","data","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","sharp","payload","file","uploadEdits","parseUploadEditsFromReqOrIncomingData","disableLocalStorage","focalPoint","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","staticPath","filename","url","startsWith","filePath","response","uploadConfig","err","t","Error","message","undefined","sync","newData","filesToSave","fileData","fileIsAnimatedType","includes","mimetype","cropData","crop","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","push","buffer","path","promises","writeFile","Array","isArray","payloadUploadSizes","sizeData","sizesToSave","savedFilename","sizes","focalX","x","focalY","y","logger","error","args","query","incomingData","origDoc"],"mappings":"AAEA,SAASA,kBAAkB,QAAQ,YAAW;AAC9C,OAAOC,QAAQ,KAAI;AACnB,OAAOC,YAAY,SAAQ;AAC3B,OAAOC,cAAc,oBAAmB;AAOxC,SAASC,kBAAkB,EAAEC,eAAe,EAAEC,WAAW,QAAQ,qBAAoB;AACrF,SAASC,cAAc,QAAQ,sBAAqB;AACpD,SAASC,SAAS,QAAQ,iBAAgB;AAC1C,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,aAAa,QAAQ,qBAAoB;AAClD,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,4BAA4B,QAAQ,oBAAmB;AAChE,SAASC,OAAO,QAAQ,eAAc;AAkBtC,OAAO,MAAMC,mBAAmB,OAAU,EACxCC,YAAY,EAAEC,QAAQC,gBAAgB,EAAE,EACxCC,IAAI,EACJC,SAAS,EACTC,WAAW,EACXC,sBAAsB,EACtBC,GAAG,EACHC,kBAAkB,EACV;IACR,IAAI,CAACN,iBAAiBO,MAAM,EAAE;QAC5B,OAAO;YACLN;YACAO,OAAO,EAAE;QACX;IACF;IAEA,MAAM,EAAEC,KAAK,EAAE,GAAGJ,IAAIK,OAAO,CAACX,MAAM;IAEpC,IAAIY,OAAON,IAAIM,IAAI;IAEnB,MAAMC,cAAcC,sCAAsC;QACxDZ;QACAC;QACAC;QACAE;IACF;IAEA,MAAM,EACJS,mBAAmB,EACnBC,YAAYC,oBAAoB,IAAI,EACpCC,aAAa,EACbC,UAAU,EACVC,aAAa,EACbC,SAAS,EACTC,WAAW,EACZ,GAAGrB,iBAAiBO,MAAM;IAE3B,MAAMe,aAAaF;IAEnB,IAAI,CAACT,QAAQC,eAAeX,MAAM;QAChC,MAAM,EAAEsB,QAAQ,EAAEC,GAAG,EAAE,GAAGvB;QAE1B,IAAI;YACF,IAAIuB,OAAOA,IAAIC,UAAU,CAAC,QAAQ,CAACX,qBAAqB;gBACtD,MAAMY,WAAW,CAAC,EAAEJ,WAAW,CAAC,EAAEC,SAAS,CAAC;gBAC5C,MAAMI,WAAW,MAAMnC,cAAckC;gBACrCf,OAAOgB;gBACPvB,yBAAyB;YAC3B,OAAO,IAAImB,YAAYC,KAAK;gBAC1Bb,OAAO,MAAMpB,gBAAgB;oBAC3BU,MAAMA;oBACNI;oBACAuB,cAAc5B,iBAAiBO,MAAM;gBACvC;gBACAH,yBAAyB;YAC3B;QACF,EAAE,OAAOyB,KAAc;YACrB,MAAM,IAAI3C,mBAAmBmB,IAAIyB,CAAC,EAAED,eAAeE,QAAQF,IAAIG,OAAO,GAAGC;QAC3E;IACF;IAEA,IAAI,CAACtB,MAAM;QACT,IAAIL,oBAAoB,MAAM,IAAIlB,YAAYiB,IAAIyB,CAAC;QAEnD,OAAO;YACL7B;YACAO,OAAO,EAAE;QACX;IACF;IAEA,IAAI,CAACM,qBAAqB;QACxB9B,OAAOkD,IAAI,CAACZ;IACd;IAEA,IAAIa,UAAUlC;IACd,MAAMmC,cAA4B,EAAE;IACpC,MAAMC,WAA8B,CAAC;IACrC,MAAMC,qBAAqB;QAAC;QAAc;QAAa;KAAa,CAACC,QAAQ,CAAC5B,KAAK6B,QAAQ;IAC3F,MAAMC,WACJ,OAAO7B,gBAAgB,YAAY,UAAUA,cAAcA,YAAY8B,IAAI,GAAGT;IAEhF,IAAI;QACF,MAAMU,qBAAqBtD,eAAesB,KAAK6B,QAAQ;QACvD,IAAII;QACJ,IAAIC;QACJ,IAAIC;QACJ,IAAIC;QACJ,IAAIC;QACJ,IAAIC;QACJ,MAAMC,qBACJP,sBACAQ,QAAQhC,iBAAiBF,iBAAiBC,cAAcG,eAAeV,KAAKyC,YAAY;QAE1F,MAAMC,eAA6B,CAAC;QAEpC,IAAIf,oBAAoBe,aAAaC,QAAQ,GAAG;QAEhD,IAAI7C,SAAU6B,CAAAA,sBAAsBY,kBAAiB,GAAI;YACvD,IAAIvC,KAAKyC,YAAY,EAAE;gBACrBP,YAAYpC,MAAME,KAAKyC,YAAY,EAAEC,cAAcE,MAAM,GAAG,mGAAmG;;YACjK,OAAO;gBACLV,YAAYpC,MAAME,KAAKV,IAAI,EAAEoD,cAAcE,MAAM,GAAG,mGAAmG;;YACzJ;YAEA,IAAIL,oBAAoB;gBACtB,IAAI/B,eAAe;oBACjB0B,YAAYA,UAAUW,MAAM,CAACrC;gBAC/B;gBACA,IAAIF,eAAe;oBACjB4B,YAAYA,UAAUY,QAAQ,CAACxC,cAAcyC,MAAM,EAAEzC,cAAc0C,OAAO;gBAC5E;gBACA,IAAItC,aAAa;oBACfwB,YAAYA,UAAUe,IAAI,CAACvC;gBAC7B;YACF;QACF;QAEA,IAAIsB,sBAAsB/C,QAAQe,KAAK6B,QAAQ,GAAG;YAChDM,aAAa,MAAMrD,aAAakB;YAChC0B,SAASwB,KAAK,GAAGf,WAAWe,KAAK;YACjCxB,SAASyB,MAAM,GAAGhB,WAAWgB,MAAM;QACrC;QAEA,IAAIjB,WAAW;YACb,MAAMkB,WAAW,MAAMlB,UAAUkB,QAAQ;YACzChB,aAAa,MAAMF,UAAUmB,QAAQ,CAAC;gBAAEC,mBAAmB;YAAK;YAC9D,CAAA,EAAEjB,GAAG,EAAEC,IAAI,EAAE,GAAG,MAAMnE,mBAAmBiE,WAAW9C,IAAI,EAAG,gDAAgD;YAAnD;YAC1DoC,SAASwB,KAAK,GAAGd,WAAWmB,IAAI,CAACL,KAAK;YACtCxB,SAASyB,MAAM,GAAGf,WAAWmB,IAAI,CAACJ,MAAM;YACxCzB,SAAS8B,QAAQ,GAAGpB,WAAWmB,IAAI,CAACE,IAAI;YAExC,0GAA0G;YAC1G,IAAIL,SAASM,KAAK,EAAE;gBAClBhC,SAASyB,MAAM,GAAGf,WAAWmB,IAAI,CAACJ,MAAM,GAAGC,SAASM,KAAK;gBACzDhC,SAAS8B,QAAQ,GAAGpB,WAAW9C,IAAI,CAACqE,MAAM;YAC5C;QACF,OAAO;YACLrB,OAAOtC,KAAK6B,QAAQ;YACpBH,SAAS8B,QAAQ,GAAGxD,KAAKyD,IAAI;YAE7B,IAAIzD,KAAK4D,IAAI,CAAChC,QAAQ,CAAC,MAAM;gBAC3BS,MAAMrC,KAAK4D,IAAI,CAACC,KAAK,CAAC,KAAKC,GAAG;YAChC,OAAO;gBACLzB,MAAM;YACR;QACF;QAEA,+CAA+C;QAC/C,IAAIC,SAAS,qBAAqBD,QAAQ,OAAOC,OAAO;QACxDZ,SAASqC,QAAQ,GAAGzB;QAEpB,MAAM0B,eAAe1F,SAAS0B,KAAK4D,IAAI,CAACK,SAAS,CAAC,GAAGjE,KAAK4D,IAAI,CAACM,WAAW,CAAC,SAASlE,KAAK4D,IAAI;QAC7F3B,aAAa,CAAC,EAAE+B,aAAa,EAAE3B,MAAM,CAAC,CAAC,EAAEA,IAAI,CAAC,GAAG,GAAG,CAAC;QAErD,IAAI,CAAC5C,wBAAwB;YAC3BwC,aAAa,MAAMlD,gBAAgB;gBACjCoF,gBAAgB9E,iBAAiB+E,IAAI;gBACrCC,iBAAiBpC;gBACjBvC;gBACAiB;YACF;QACF;QAEAe,SAASd,QAAQ,GAAGqB;QACpB,IAAIqC,gBAAgBtE;QAEpB,IAAI8B,YAAYhC,OAAO;YACrB,MAAM,EAAER,MAAMiF,YAAY,EAAEhB,IAAI,EAAE,GAAG,MAAM5E,UAAU;gBAAEmD;gBAAUK;gBAAYnC;gBAAMF;YAAM;YAEzF2B,YAAY+C,IAAI,CAAC;gBACfC,QAAQF;gBACRG,MAAM,CAAC,EAAE/D,WAAW,CAAC,EAAEsB,WAAW,CAAC;YACrC;YAEAqC,gBAAgB;gBACd,GAAGtE,IAAI;gBACPV,MAAMiF;gBACNd,MAAMF,KAAKE,IAAI;YACjB;YACA/B,SAASwB,KAAK,GAAGK,KAAKL,KAAK;YAC3BxB,SAASyB,MAAM,GAAGI,KAAKJ,MAAM;YAC7B,IAAIxB,oBAAoB;gBACtB,MAAMyB,WAAW,MAAMlB,UAAUkB,QAAQ;gBACzC1B,SAASyB,MAAM,GAAGC,SAASM,KAAK,GAAGH,KAAKJ,MAAM,GAAGC,SAASM,KAAK,GAAGH,KAAKJ,MAAM;YAC/E;YACAzB,SAAS8B,QAAQ,GAAGD,KAAKE,IAAI;YAE7B,IAAIzD,KAAKyC,YAAY,EAAE;gBACrB,MAAMrE,GAAGuG,QAAQ,CAACC,SAAS,CAAC5E,KAAKyC,YAAY,EAAE8B,cAAc,oCAAoC;;YACnG,OAAO;gBACL7E,IAAIM,IAAI,GAAGsE;YACb;QACF,OAAO;YACL7C,YAAY+C,IAAI,CAAC;gBACfC,QAAQrC,YAAY9C,QAAQU,KAAKV,IAAI;gBACrCoF,MAAM,CAAC,EAAE/D,WAAW,CAAC,EAAEsB,WAAW,CAAC;YACrC;YAEA,sFAAsF;YACtF,IAAIG,YAAY9C,QAAQU,KAAKV,IAAI,CAACqE,MAAM,GAAG,GAAG;gBAC5C,IAAI3D,KAAKyC,YAAY,EAAE;oBACrB,MAAMrE,GAAGuG,QAAQ,CAACC,SAAS,CAAC5E,KAAKyC,YAAY,EAAEL,YAAY9C,QAAQU,KAAKV,IAAI,EAAE,oCAAoC;;gBACpH,OAAO;oBACL,4DAA4D;oBAC5DI,IAAIM,IAAI,GAAG;wBACT,GAAGA,IAAI;wBACPV,MAAM8C,YAAY9C,QAAQU,KAAKV,IAAI;wBACnCmE,MAAMrB,YAAYmB,KAAKE;oBACzB;gBACF;YACF;QACF;QAEA,IAAIzB,sBAAuB6C,CAAAA,MAAMC,OAAO,CAACvE,eAAeF,sBAAsB,KAAI,GAAI;YACpFX,IAAIqF,kBAAkB,GAAG,CAAC;YAC1B,MAAM,EAAE3E,UAAU,EAAE4E,QAAQ,EAAEC,WAAW,EAAE,GAAG,MAAMjG,6BAA6B;gBAC/EI,QAAQC;gBACR8C,YAAY,CAACL,WACTK,aACA;oBACE,GAAGA,UAAU;oBACbgB,QAAQzB,SAASyB,MAAM;oBACvBD,OAAOxB,SAASwB,KAAK;gBACvB;gBACJlD,MAAMsE;gBACNP,UAAUrC,SAASqC,QAAQ;gBAC3BrE;gBACAwF,eAAejD,cAAcjC,KAAK4D,IAAI;gBACtC9D;gBACAa;gBACAV;YACF;YAEAyB,SAASyD,KAAK,GAAGH;YACjBtD,SAAS0D,MAAM,GAAGhF,YAAYiF;YAC9B3D,SAAS4D,MAAM,GAAGlF,YAAYmF;YAC9B9D,YAAY+C,IAAI,IAAIS;QACtB;IACF,EAAE,OAAO/D,KAAK;QACZxB,IAAIK,OAAO,CAACyF,MAAM,CAACC,KAAK,CAACvE;QACzB,MAAM,IAAI1C,gBAAgBkB,IAAIyB,CAAC;IACjC;IAEAK,UAAU;QACR,GAAGA,OAAO;QACV,GAAGE,QAAQ;IACb;IAEA,OAAO;QACLpC,MAAMkC;QACN3B,OAAO4B;IACT;AACF,EAAC;AAED;;CAEC,GACD,SAASvB,sCAAsCwF,IAK9C;IACC,MAAM,EAAEpG,IAAI,EAAEC,SAAS,EAAEC,WAAW,EAAEE,GAAG,EAAE,GAAGgG;IAE9C,qEAAqE;IACrE,MAAM,EACJzF,cAAc,CAAC,CAAC,EACjB,GAEGP,IAAIiG,KAAK,IAAI,CAAC;IAElB,IAAI1F,YAAYG,UAAU,EAAE,OAAOH;IAEnC,MAAM2F,eAAetG;IACrB,MAAMuG,UAAUrG;IAEhB,iDAAiD;IACjD,mGAAmG;IACnG,IAAIqG,WAAWD,aAAaR,MAAM,KAAKS,QAAQT,MAAM,IAAIQ,aAAaN,MAAM,KAAKO,QAAQP,MAAM,EAAE;QAC/F,OAAOhE;IACT;IAEA,IAAIsE,cAAcR,UAAUQ,cAAcN,QAAQ;QAChDrF,YAAYG,UAAU,GAAG;YACvBiF,GAAGO,aAAaR,MAAM;YACtBG,GAAGK,aAAaN,MAAM;QACxB;QACA,OAAOrF;IACT;IAEA,8CAA8C;IAC9C,IAAIV,cAAc,UAAU;QAC1BU,YAAYG,UAAU,GAAG;YACvBiF,GAAG;YACHE,GAAG;QACL;IACF;IACA,OAAOtF;AACT"}