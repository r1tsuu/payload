{"version":3,"sources":["../../src/uploads/imageResizer.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs'\nimport sanitize from 'sanitize-filename'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SharpDependency } from '../config/types.js'\nimport type { PayloadRequestWithData } from '../types/index.js'\nimport type {\n  FileSize,\n  FileSizes,\n  FileToSave,\n  ImageSize,\n  ProbedImageSize,\n  UploadEdits,\n} from './types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport fileExists from './fileExists.js'\n\ntype ResizeArgs = {\n  config: SanitizedCollectionConfig\n  dimensions: ProbedImageSize\n  file: PayloadRequestWithData['file']\n  mimeType: string\n  req: PayloadRequestWithData\n  savedFilename: string\n  sharp?: SharpDependency\n  staticPath: string\n  uploadEdits?: UploadEdits\n}\n\n/** Result from resizing and transforming the requested image sizes */\ntype ImageSizesResult = {\n  focalPoint?: UploadEdits['focalPoint']\n  sizeData: FileSizes\n  sizesToSave: FileToSave[]\n}\n\ntype SanitizedImageData = {\n  ext: string\n  name: string\n}\n\n/**\n * Sanitize the image name and extract the extension from the source image\n *\n * @param sourceImage - the source image\n * @returns the sanitized name and extension\n */\nconst getSanitizedImageData = (sourceImage: string): SanitizedImageData => {\n  const extension = sourceImage.split('.').pop()\n  const name = sanitize(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage)\n  return { name, ext: extension }\n}\n\n/**\n * Create a new image name based on the output image name, the dimensions and\n * the extension.\n *\n * Ignore the fact that duplicate names could happen if the there is one\n * size with `width AND height` and one with only `height OR width`. Because\n * space is expensive, we will reuse the same image for both sizes.\n *\n * @param outputImageName - the sanitized image name\n * @param bufferInfo - the buffer info\n * @param extension - the extension to use\n * @returns the new image name that is not taken\n */\nconst createImageName = (\n  outputImageName: string,\n  { height, width }: OutputInfo,\n  extension: string,\n) => `${outputImageName}-${width}x${height}.${extension}`\n\ntype CreateResultArgs = {\n  filename?: FileSize['filename']\n  filesize?: FileSize['filesize']\n  height?: FileSize['height']\n  mimeType?: FileSize['mimeType']\n  name: string\n  sizesToSave?: FileToSave[]\n  width?: FileSize['width']\n}\n\n/**\n * Create the result object for the image resize operation based on the\n * provided parameters. If the name is not provided, an empty result object\n * is returned.\n *\n * @param name - the name of the image\n * @param filename - the filename of the image\n * @param width - the width of the image\n * @param height - the height of the image\n * @param filesize - the filesize of the image\n * @param mimeType - the mime type of the image\n * @param sizesToSave - the sizes to save\n * @returns the result object\n */\nconst createResult = ({\n  name,\n  filename = null,\n  filesize = null,\n  height = null,\n  mimeType = null,\n  sizesToSave = [],\n  width = null,\n}: CreateResultArgs): ImageSizesResult => {\n  return {\n    sizeData: {\n      [name]: {\n        filename,\n        filesize,\n        height,\n        mimeType,\n        width,\n      },\n    },\n    sizesToSave,\n  }\n}\n\n/**\n * Check if the image needs to be resized according to the requested dimensions\n * and the original image size. If the resize options withoutEnlargement or withoutReduction are provided,\n * the image will be resized regardless of the requested dimensions, given that the\n * width or height to be resized is provided.\n *\n * @param resizeConfig - object containing the requested dimensions and resize options\n * @param original - the original image size\n * @returns true if resizing is not needed, false otherwise\n */\nconst preventResize = (\n  { height: desiredHeight, width: desiredWidth, withoutEnlargement, withoutReduction }: ImageSize,\n  original: ProbedImageSize,\n): boolean => {\n  // default is to allow reduction\n  if (withoutReduction !== undefined) {\n    return false // needs resize\n  }\n\n  // default is to prevent enlargement\n  if (withoutEnlargement !== undefined) {\n    return false // needs resize\n  }\n\n  const isWidthOrHeightNotDefined = !desiredHeight || !desiredWidth\n  if (isWidthOrHeightNotDefined) {\n    // If width and height are not defined, it means there is a format conversion\n    // and the image needs to be \"resized\" (transformed).\n    return false // needs resize\n  }\n\n  const hasInsufficientWidth = desiredWidth > original.width\n  const hasInsufficientHeight = desiredHeight > original.height\n  if (hasInsufficientWidth && hasInsufficientHeight) {\n    // doesn't need resize - prevent enlargement. This should only happen if both width and height are insufficient.\n    // if only one dimension is insufficient and the other is sufficient, resizing needs to happen, as the image\n    // should be resized to the sufficient dimension.\n    return true // do not create a new size\n  }\n\n  return false // needs resize\n}\n\n/**\n * Check if the image should be passed directly to sharp without payload adjusting properties.\n *\n * @param resizeConfig - object containing the requested dimensions and resize options\n * @param original - the original image size\n * @returns true if the image should passed directly to sharp\n */\nconst applyPayloadAdjustments = (\n  { fit, height, width, withoutEnlargement, withoutReduction }: ImageSize,\n  original: ProbedImageSize,\n) => {\n  if (fit === 'contain' || fit === 'inside') return false\n  if (!isNumber(height) && !isNumber(width)) return false\n\n  const targetAspectRatio = width / height\n  const originalAspectRatio = original.width / original.height\n  if (originalAspectRatio === targetAspectRatio) return false\n\n  const skipEnlargement = withoutEnlargement && (original.height < height || original.width < width)\n  const skipReduction = withoutReduction && (original.height > height || original.width > width)\n  if (skipEnlargement || skipReduction) return false\n\n  return true\n}\n\n/**\n * Sanitize the resize config. If the resize config has the `withoutReduction`\n * property set to true, the `fit` and `position` properties will be set to `contain`\n * and `top left` respectively.\n *\n * @param resizeConfig - the resize config\n * @returns a sanitized resize config\n */\nconst sanitizeResizeConfig = (resizeConfig: ImageSize): ImageSize => {\n  if (resizeConfig.withoutReduction) {\n    return {\n      ...resizeConfig,\n      // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595\n      fit: resizeConfig?.fit || 'contain',\n      position: resizeConfig?.position || 'left top',\n    }\n  }\n  return resizeConfig\n}\n\n/**\n * For the provided image sizes, handle the resizing and the transforms\n * (format, trim, etc.) of each requested image size and return the result object.\n * This only handles the image sizes. The transforms of the original image\n * are handled in {@link ./generateFileData.ts}.\n *\n * The image will be resized according to the provided\n * resize config. If no image sizes are requested, the resolved data will be empty.\n * For every image that does not need to be resized, a result object with `null`\n * parameters will be returned.\n *\n * @param resizeConfig - the resize config\n * @returns the result of the resize operation(s)\n */\nexport async function resizeAndTransformImageSizes({\n  config,\n  dimensions,\n  file,\n  mimeType,\n  req,\n  savedFilename,\n  sharp,\n  staticPath,\n  uploadEdits,\n}: ResizeArgs): Promise<ImageSizesResult> {\n  const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload\n\n  // Focal point adjustments\n  const incomingFocalPoint = uploadEdits.focalPoint\n    ? {\n        x: isNumber(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,\n        y: isNumber(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50,\n      }\n    : undefined\n\n  const defaultResult: ImageSizesResult = {\n    ...(focalPointEnabled && incomingFocalPoint && { focalPoint: incomingFocalPoint }),\n    sizeData: {},\n    sizesToSave: [],\n  }\n\n  if (!imageSizes || !sharp) {\n    return defaultResult\n  }\n\n  // Determine if the file is animated\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const sharpOptions: SharpOptions = {}\n\n  if (fileIsAnimatedType) sharpOptions.animated = true\n\n  const sharpBase: Sharp | undefined = sharp(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n\n  const results: ImageSizesResult[] = await Promise.all(\n    imageSizes.map(async (imageResizeConfig): Promise<ImageSizesResult> => {\n      imageResizeConfig = sanitizeResizeConfig(imageResizeConfig)\n\n      // This checks if a resize should happen. If not, the resized image will be\n      // skipped COMPLETELY and thus will not be included in the resulting images.\n      // All further format/trim options will thus be skipped as well.\n      if (preventResize(imageResizeConfig, dimensions)) {\n        return createResult({ name: imageResizeConfig.name })\n      }\n\n      const imageToResize = sharpBase.clone()\n      let resized = imageToResize\n\n      const metadata = await sharpBase.metadata()\n\n      if (incomingFocalPoint && applyPayloadAdjustments(imageResizeConfig, dimensions)) {\n        let { height: resizeHeight, width: resizeWidth } = imageResizeConfig\n\n        const originalAspectRatio = dimensions.width / dimensions.height\n\n        // Calculate resizeWidth based on original aspect ratio if it's undefined\n        if (resizeHeight && !resizeWidth) {\n          resizeWidth = Math.round(resizeHeight * originalAspectRatio)\n        }\n\n        // Calculate resizeHeight based on original aspect ratio if it's undefined\n        if (resizeWidth && !resizeHeight) {\n          resizeHeight = Math.round(resizeWidth / originalAspectRatio)\n        }\n\n        // Scale the image up or down to fit the resize dimensions\n        const scaledImage = imageToResize.resize({\n          height: resizeHeight,\n          width: resizeWidth,\n        })\n\n        const { info: scaledImageInfo } = await scaledImage.toBuffer({ resolveWithObject: true })\n\n        const safeResizeWidth = resizeWidth ?? scaledImageInfo.width\n        const maxOffsetX = scaledImageInfo.width - safeResizeWidth\n        const leftFocalEdge = Math.round(\n          scaledImageInfo.width * (incomingFocalPoint.x / 100) - safeResizeWidth / 2,\n        )\n        const safeOffsetX = Math.min(Math.max(0, leftFocalEdge), maxOffsetX)\n\n        const isAnimated = fileIsAnimatedType && metadata.pages\n\n        let safeResizeHeight = resizeHeight ?? scaledImageInfo.height\n\n        if (isAnimated && resizeHeight === undefined) {\n          safeResizeHeight = scaledImageInfo.height / metadata.pages\n        }\n\n        const maxOffsetY = isAnimated\n          ? safeResizeHeight - (resizeHeight ?? safeResizeHeight)\n          : scaledImageInfo.height - safeResizeHeight\n\n        const topFocalEdge = Math.round(\n          scaledImageInfo.height * (incomingFocalPoint.y / 100) - safeResizeHeight / 2,\n        )\n        const safeOffsetY = Math.min(Math.max(0, topFocalEdge), maxOffsetY)\n\n        // extract the focal area from the scaled image\n        resized = (fileIsAnimatedType ? imageToResize : scaledImage).extract({\n          height: safeResizeHeight,\n          left: safeOffsetX,\n          top: safeOffsetY,\n          width: safeResizeWidth,\n        })\n      } else {\n        resized = imageToResize.resize(imageResizeConfig)\n      }\n\n      if (imageResizeConfig.formatOptions) {\n        resized = resized.toFormat(\n          imageResizeConfig.formatOptions.format,\n          imageResizeConfig.formatOptions.options,\n        )\n      }\n\n      if (imageResizeConfig.trimOptions) {\n        resized = resized.trim(imageResizeConfig.trimOptions)\n      }\n\n      const { data: bufferData, info: bufferInfo } = await resized.toBuffer({\n        resolveWithObject: true,\n      })\n\n      const sanitizedImage = getSanitizedImageData(savedFilename)\n\n      if (req.payloadUploadSizes) {\n        req.payloadUploadSizes[imageResizeConfig.name] = bufferData\n      }\n\n      const mimeInfo = await fileTypeFromBuffer(bufferData)\n\n      const imageNameWithDimensions = createImageName(\n        sanitizedImage.name,\n        bufferInfo,\n        mimeInfo?.ext || sanitizedImage.ext,\n      )\n\n      const imagePath = `${staticPath}/${imageNameWithDimensions}`\n\n      if (await fileExists(imagePath)) {\n        try {\n          fs.unlinkSync(imagePath)\n        } catch {\n          // Ignore unlink errors\n        }\n      }\n\n      const { height, size, width } = bufferInfo\n      return createResult({\n        name: imageResizeConfig.name,\n        filename: imageNameWithDimensions,\n        filesize: size,\n        height: fileIsAnimatedType && metadata.pages ? height / metadata.pages : height,\n        mimeType: mimeInfo?.mime || mimeType,\n        sizesToSave: [{ buffer: bufferData, path: imagePath }],\n        width,\n      })\n    }),\n  )\n\n  return results.reduce(\n    (acc, result) => {\n      Object.assign(acc.sizeData, result.sizeData)\n      acc.sizesToSave.push(...result.sizesToSave)\n      return acc\n    },\n    { ...defaultResult },\n  )\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","isNumber","fileExists","getSanitizedImageData","sourceImage","extension","split","pop","name","substring","lastIndexOf","ext","createImageName","outputImageName","height","width","createResult","filename","filesize","mimeType","sizesToSave","sizeData","preventResize","desiredHeight","desiredWidth","withoutEnlargement","withoutReduction","original","undefined","isWidthOrHeightNotDefined","hasInsufficientWidth","hasInsufficientHeight","applyPayloadAdjustments","fit","targetAspectRatio","originalAspectRatio","skipEnlargement","skipReduction","sanitizeResizeConfig","resizeConfig","position","resizeAndTransformImageSizes","config","dimensions","file","req","savedFilename","sharp","staticPath","uploadEdits","focalPoint","focalPointEnabled","imageSizes","upload","incomingFocalPoint","x","Math","round","y","defaultResult","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","sharpBase","tempFilePath","data","rotate","results","Promise","all","map","imageResizeConfig","imageToResize","clone","resized","metadata","resizeHeight","resizeWidth","scaledImage","resize","info","scaledImageInfo","toBuffer","resolveWithObject","safeResizeWidth","maxOffsetX","leftFocalEdge","safeOffsetX","min","max","isAnimated","pages","safeResizeHeight","maxOffsetY","topFocalEdge","safeOffsetY","extract","left","top","formatOptions","toFormat","format","options","trimOptions","trim","bufferData","bufferInfo","sanitizedImage","payloadUploadSizes","mimeInfo","imageNameWithDimensions","imagePath","unlinkSync","size","mime","buffer","path","reduce","acc","result","Object","assign","push"],"mappings":"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"}