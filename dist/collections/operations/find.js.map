{"version":3,"sources":["../../../src/collections/operations/find.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { PaginatedDocs } from '../../database/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequestWithData, Where } from '../../types/index.js'\nimport type { Collection, DataFromCollectionSlug } from '../config/types.js'\n\nimport executeAccess from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\nimport { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'\nimport { getQueryDraftsSort } from '../../versions/drafts/getQueryDraftsSort.js'\nimport { buildAfterOperation } from './utils.js'\n\nexport type Arguments = {\n  collection: Collection\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  req?: PayloadRequestWithData\n  showHiddenFields?: boolean\n  sort?: string\n  where?: Where\n}\n\nexport const findOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<PaginatedDocs<DataFromCollectionSlug<TSlug>>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = await initTransaction(args.req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      args =\n        (await hook({\n          args,\n          collection: args.collection.config,\n          context: args.req.context,\n          operation: 'read',\n          req: args.req,\n        })) || args\n    }, Promise.resolve())\n\n    const {\n      collection: { config: collectionConfig },\n      collection,\n      currentDepth,\n      depth,\n      disableErrors,\n      draft: draftsEnabled,\n      limit,\n      overrideAccess,\n      page,\n      pagination = true,\n      req: { fallbackLocale, locale, payload },\n      req,\n      showHiddenFields,\n      sort,\n      where,\n    } = args\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)\n\n      // If errors are disabled, and access returns false, return empty results\n      if (accessResult === false) {\n        return {\n          docs: [],\n          hasNextPage: false,\n          hasPrevPage: false,\n          limit,\n          nextPage: null,\n          page: 1,\n          pagingCounter: 1,\n          prevPage: null,\n          totalDocs: 0,\n          totalPages: 1,\n        }\n      }\n    }\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const usePagination = pagination && limit !== 0\n    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)\n    const sanitizedPage = page || 1\n\n    let result: PaginatedDocs<DataFromCollectionSlug<TSlug>>\n\n    let fullWhere = combineQueries(where, accessResult)\n\n    if (collectionConfig.versions?.drafts && draftsEnabled) {\n      fullWhere = appendVersionToQueryKey(fullWhere)\n\n      await validateQueryPaths({\n        collectionConfig: collection.config,\n        overrideAccess,\n        req,\n        versionFields: buildVersionCollectionFields(collection.config),\n        where: fullWhere,\n      })\n\n      result = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({\n        collection: collectionConfig.slug,\n        limit: sanitizedLimit,\n        locale,\n        page: sanitizedPage,\n        pagination: usePagination,\n        req,\n        sort: getQueryDraftsSort(sort),\n        where: fullWhere,\n      })\n    } else {\n      await validateQueryPaths({\n        collectionConfig,\n        overrideAccess,\n        req,\n        where,\n      })\n\n      result = await payload.db.find<DataFromCollectionSlug<TSlug>>({\n        collection: collectionConfig.slug,\n        limit: sanitizedLimit,\n        locale,\n        page: sanitizedPage,\n        pagination,\n        req,\n        sort,\n        where: fullWhere,\n      })\n    }\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (doc) => {\n          let docRef = doc\n\n          await collectionConfig.hooks.beforeRead.reduce(async (priorHook, hook) => {\n            await priorHook\n\n            docRef =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef,\n                query: fullWhere,\n                req,\n              })) || docRef\n          }, Promise.resolve())\n\n          return docRef\n        }),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (doc) =>\n          afterRead<DataFromCollectionSlug<TSlug>>({\n            collection: collectionConfig,\n            context: req.context,\n            currentDepth,\n            depth,\n            doc,\n            draft: draftsEnabled,\n            fallbackLocale,\n            findMany: true,\n            global: null,\n            locale,\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        ),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: await Promise.all(\n        result.docs.map(async (doc) => {\n          let docRef = doc\n\n          await collectionConfig.hooks.afterRead.reduce(async (priorHook, hook) => {\n            await priorHook\n\n            docRef =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef,\n                findMany: true,\n                query: fullWhere,\n                req,\n              })) || doc\n          }, Promise.resolve())\n\n          return docRef\n        }),\n      ),\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'find',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) await commitTransaction(req)\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","afterRead","commitTransaction","initTransaction","killTransaction","buildVersionCollectionFields","appendVersionToQueryKey","getQueryDraftsSort","buildAfterOperation","findOperation","incomingArgs","args","shouldCommit","req","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","operation","Promise","resolve","collectionConfig","currentDepth","depth","disableErrors","draft","draftsEnabled","limit","overrideAccess","page","pagination","fallbackLocale","locale","payload","showHiddenFields","sort","where","accessResult","access","read","docs","hasNextPage","hasPrevPage","nextPage","pagingCounter","prevPage","totalDocs","totalPages","usePagination","sanitizedLimit","sanitizedPage","result","fullWhere","versions","drafts","versionFields","db","queryDrafts","slug","find","all","map","doc","docRef","beforeRead","query","findMany","global","error"],"mappings":"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"}