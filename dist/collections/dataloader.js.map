{"version":3,"sources":["../../src/collections/dataloader.ts"],"sourcesContent":["import type { BatchLoadFn } from 'dataloader'\n\nimport DataLoader from 'dataloader'\n\nimport type { PayloadRequest, PayloadRequestWithData } from '../types/index.js'\nimport type { TypeWithID } from './config/types.js'\n\nimport { isValidID } from '../utilities/isValidID.js'\n\n// Payload uses `dataloader` to solve the classic GraphQL N+1 problem.\n\n// We keep a list of all documents requested to be populated for any given request\n// and then batch together documents within the same collection,\n// making only 1 find per each collection, rather than `findByID` per each requested doc.\n\n// This dramatically improves performance for REST and Local API `depth` populations,\n// and also ensures complex GraphQL queries perform lightning-fast.\n\nconst batchAndLoadDocs =\n  (req: PayloadRequest): BatchLoadFn<string, TypeWithID> =>\n  async (keys: string[]): Promise<TypeWithID[]> => {\n    const { payload } = req\n\n    // Create docs array of same length as keys, using null as value\n    // We will replace nulls with injected docs as they are retrieved\n    const docs: (TypeWithID | null)[] = keys.map(() => null)\n\n    /**\n    * Batch IDs by their `find` args\n    * so we can make one find query per combination of collection, depth, locale, and fallbackLocale.\n    *\n    * Resulting shape will be as follows:\n      {\n        // key is stringified set of find args\n        '[null,\"pages\",2,0,\"es\",\"en\",false,false]': [\n          // value is array of IDs to find with these args\n          'q34tl23462346234524',\n          '435523540194324280',\n          '2346245j35l3j5234532li',\n        ],\n        // etc\n      };\n    *\n    **/\n\n    const batchByFindArgs = keys.reduce((batches, key) => {\n      const [\n        transactionID,\n        collection,\n        id,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n      ] = JSON.parse(key)\n\n      const batchKeyArray = [\n        transactionID,\n        collection,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n      ]\n\n      const batchKey = JSON.stringify(batchKeyArray)\n\n      const idType = payload.collections?.[collection].customIDType || payload.db.defaultIDType\n\n      let sanitizedID: number | string = id\n\n      if (idType === 'number') sanitizedID = parseFloat(id)\n\n      if (isValidID(sanitizedID, idType)) {\n        return {\n          ...batches,\n          [batchKey]: [...(batches[batchKey] || []), sanitizedID],\n        }\n      }\n      return batches\n    }, {})\n\n    // Run find requests one after another, so as to not hang transactions\n\n    await Object.entries(batchByFindArgs).reduce(async (priorFind, [batchKey, ids]) => {\n      await priorFind\n\n      const [\n        transactionID,\n        collection,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n      ] = JSON.parse(batchKey)\n\n      req.transactionID = transactionID\n\n      const result = await payload.find({\n        collection,\n        currentDepth,\n        depth,\n        disableErrors: true,\n        draft,\n        fallbackLocale,\n        locale,\n        overrideAccess: Boolean(overrideAccess),\n        pagination: false,\n        req: req as PayloadRequestWithData,\n        showHiddenFields: Boolean(showHiddenFields),\n        where: {\n          id: {\n            in: ids,\n          },\n        },\n      })\n\n      // For each returned doc, find index in original keys\n      // Inject doc within docs array if index exists\n\n      result.docs.forEach((doc) => {\n        const docKey = createDataloaderCacheKey({\n          collectionSlug: collection,\n          currentDepth,\n          depth,\n          docID: doc.id,\n          draft,\n          fallbackLocale: req.fallbackLocale,\n          locale: req.locale,\n          overrideAccess,\n          showHiddenFields,\n          transactionID: req.transactionID,\n        })\n        const docsIndex = keys.findIndex((key) => key === docKey)\n\n        if (docsIndex > -1) {\n          docs[docsIndex] = doc\n        }\n      })\n    }, Promise.resolve())\n\n    // Return docs array,\n    // which has now been injected with all fetched docs\n    // and should match the length of the incoming keys arg\n    return docs\n  }\n\nexport const getDataLoader = (req: PayloadRequest) => new DataLoader(batchAndLoadDocs(req))\n\ntype CreateCacheKeyArgs = {\n  collectionSlug: string\n  currentDepth: number\n  depth: number\n  docID: number | string\n  draft: boolean\n  fallbackLocale: string\n  locale: string\n  overrideAccess: boolean\n  showHiddenFields: boolean\n  transactionID: number | string\n}\nexport const createDataloaderCacheKey = ({\n  collectionSlug,\n  currentDepth,\n  depth,\n  docID,\n  draft,\n  fallbackLocale,\n  locale,\n  overrideAccess,\n  showHiddenFields,\n  transactionID,\n}: CreateCacheKeyArgs): string =>\n  JSON.stringify([\n    transactionID,\n    collectionSlug,\n    docID,\n    depth,\n    currentDepth,\n    locale,\n    fallbackLocale,\n    overrideAccess,\n    showHiddenFields,\n    draft,\n  ])\n"],"names":["DataLoader","isValidID","batchAndLoadDocs","req","keys","payload","docs","map","batchByFindArgs","reduce","batches","key","transactionID","collection","id","depth","currentDepth","locale","fallbackLocale","overrideAccess","showHiddenFields","draft","JSON","parse","batchKeyArray","batchKey","stringify","idType","collections","customIDType","db","defaultIDType","sanitizedID","parseFloat","Object","entries","priorFind","ids","result","find","disableErrors","Boolean","pagination","where","in","forEach","doc","docKey","createDataloaderCacheKey","collectionSlug","docID","docsIndex","findIndex","Promise","resolve","getDataLoader"],"mappings":"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"}