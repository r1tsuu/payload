{"version":3,"sources":["../../../src/auth/operations/refresh.ts"],"sourcesContent":["import jwt from 'jsonwebtoken'\nimport url from 'url'\n\nimport type { BeforeOperationHook, Collection } from '../../collections/config/types.js'\nimport type { Document, PayloadRequestWithData } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utils.js'\nimport { Forbidden } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\n\nexport type Result = {\n  exp: number\n  refreshedToken: string\n  setCookie?: boolean\n  strategy?: string\n  user: Document\n}\n\nexport type Arguments = {\n  collection: Collection\n  req: PayloadRequestWithData\n}\n\nexport const refreshOperation = async (incomingArgs: Arguments): Promise<Result> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = await initTransaction(args.req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    await args.collection.config.hooks.beforeOperation.reduce(\n      async (priorHook: BeforeOperationHook | Promise<void>, hook: BeforeOperationHook) => {\n        await priorHook\n\n        args =\n          (await hook({\n            args,\n            collection: args.collection?.config,\n            context: args.req.context,\n            operation: 'refresh',\n            req: args.req,\n          })) || args\n      },\n      Promise.resolve(),\n    )\n\n    // /////////////////////////////////////\n    // Refresh\n    // /////////////////////////////////////\n\n    const {\n      collection: { config: collectionConfig },\n      req,\n      req: {\n        payload: { config, secret },\n      },\n    } = args\n\n    if (!args.req.user) throw new Forbidden(args.req.t)\n\n    const parsedURL = url.parse(args.req.url)\n    const isGraphQL = parsedURL.pathname === config.routes.graphQL\n\n    const user = await args.req.payload.findByID({\n      id: args.req.user.id,\n      collection: args.req.user.collection,\n      depth: isGraphQL ? 0 : args.collection.config.auth.depth,\n      req: args.req,\n    })\n\n    let result: Result\n\n    // /////////////////////////////////////\n    // refresh hook - Collection\n    // /////////////////////////////////////\n\n    for (const refreshHook of args.collection.config.hooks.refresh) {\n      const hookResult = await refreshHook({ args, user })\n\n      if (hookResult) {\n        result = hookResult\n        break\n      }\n    }\n\n    if (!result) {\n      const fieldsToSign = getFieldsToSign({\n        collectionConfig,\n        email: user?.email as string,\n        user: args?.req?.user,\n      })\n\n      const refreshedToken = jwt.sign(fieldsToSign, secret, {\n        expiresIn: collectionConfig.auth.tokenExpiration,\n      })\n\n      const exp = (jwt.decode(refreshedToken) as Record<string, unknown>).exp as number\n\n      result = {\n        exp,\n        refreshedToken,\n        setCookie: true,\n        strategy: args.req.user._strategy,\n        user,\n      }\n    }\n\n    // /////////////////////////////////////\n    // After Refresh - Collection\n    // /////////////////////////////////////\n\n    await collectionConfig.hooks.afterRefresh.reduce(async (priorHook, hook) => {\n      await priorHook\n\n      result =\n        (await hook({\n          collection: args.collection?.config,\n          context: args.req.context,\n          exp: result.exp,\n          req: args.req,\n          token: result.refreshedToken,\n        })) || result\n    }, Promise.resolve())\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'refresh',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) await commitTransaction(req)\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["jwt","url","buildAfterOperation","Forbidden","commitTransaction","initTransaction","killTransaction","getFieldsToSign","refreshOperation","incomingArgs","args","shouldCommit","req","collection","config","hooks","beforeOperation","reduce","priorHook","hook","context","operation","Promise","resolve","collectionConfig","payload","secret","user","t","parsedURL","parse","isGraphQL","pathname","routes","graphQL","findByID","id","depth","auth","result","refreshHook","refresh","hookResult","fieldsToSign","email","refreshedToken","sign","expiresIn","tokenExpiration","exp","decode","setCookie","strategy","_strategy","afterRefresh","token","error"],"mappings":"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"}