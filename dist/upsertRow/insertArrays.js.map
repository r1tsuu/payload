{"version":3,"sources":["../../src/upsertRow/insertArrays.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { ArrayRowToInsert } from '../transform/write/types.js'\nimport type { DrizzleDB, PostgresAdapter } from '../types.js'\n\ntype Args = {\n  adapter: PostgresAdapter\n  arrays: {\n    [tableName: string]: ArrayRowToInsert[]\n  }[]\n  db: DrizzleDB\n  parentRows: Record<string, unknown>[]\n}\n\ntype RowsByTable = {\n  [tableName: string]: {\n    arrays: {\n      [tableName: string]: ArrayRowToInsert[]\n    }[]\n    locales: Record<string, unknown>[]\n    rows: Record<string, unknown>[]\n  }\n}\n\nexport const insertArrays = async ({ adapter, arrays, db, parentRows }: Args): Promise<void> => {\n  // Maintain a map of flattened rows by table\n  const rowsByTable: RowsByTable = {}\n\n  arrays.forEach((arraysByTable, parentRowIndex) => {\n    Object.entries(arraysByTable).forEach(([tableName, arrayRows]) => {\n      // If the table doesn't exist in map, initialize it\n      if (!rowsByTable[tableName]) {\n        rowsByTable[tableName] = {\n          arrays: [],\n          locales: [],\n          rows: [],\n        }\n      }\n\n      const parentID = parentRows[parentRowIndex].id\n\n      // Add any sub arrays that need to be created\n      // We will call this recursively below\n      arrayRows.forEach((arrayRow, i) => {\n        if (Object.keys(arrayRow.arrays).length > 0) {\n          rowsByTable[tableName].arrays.push(arrayRow.arrays)\n        }\n\n        // Set up parent IDs for both row and locale row\n        arrayRow.row._parentID = parentID\n        rowsByTable[tableName].rows.push(arrayRow.row)\n\n        Object.entries(arrayRow.locales).forEach(([arrayRowLocale, arrayRowLocaleData]) => {\n          arrayRowLocaleData._parentID = arrayRow.row.id\n          arrayRowLocaleData._locale = arrayRowLocale\n          rowsByTable[tableName].locales.push(arrayRowLocaleData)\n          if (!arrayRow.row.id) {\n            arrayRowLocaleData._getParentID = (rows) => rows[i].id\n          }\n        })\n      })\n    })\n  })\n\n  // Insert all corresponding arrays\n  // (one insert per array table)\n  for (const [tableName, row] of Object.entries(rowsByTable)) {\n    // the nested arrays need the ID for the parentID foreign key\n    let insertedRows: Args['parentRows']\n    if (row.rows.length > 0) {\n      insertedRows = await db.insert(adapter.tables[tableName]).values(row.rows).returning()\n    }\n\n    // Insert locale rows\n    if (adapter.tables[`${tableName}${adapter.localesSuffix}`] && row.locales.length > 0) {\n      if (!row.locales[0]._parentID) {\n        row.locales = row.locales.map((localeRow) => {\n          if (typeof localeRow._getParentID === 'function') {\n            localeRow._parentID = localeRow._getParentID(insertedRows)\n            delete localeRow._getParentID\n          }\n          return localeRow\n        })\n      }\n      await db\n        .insert(adapter.tables[`${tableName}${adapter.localesSuffix}`])\n        .values(row.locales)\n        .returning()\n    }\n\n    // If there are sub arrays, call this function recursively\n    if (row.arrays.length > 0) {\n      await insertArrays({\n        adapter,\n        arrays: row.arrays,\n        db,\n        parentRows: insertedRows,\n      })\n    }\n  }\n}\n"],"names":["insertArrays","adapter","arrays","db","parentRows","rowsByTable","forEach","arraysByTable","parentRowIndex","Object","entries","tableName","arrayRows","locales","rows","parentID","id","arrayRow","i","keys","length","push","row","_parentID","arrayRowLocale","arrayRowLocaleData","_locale","_getParentID","insertedRows","insert","tables","values","returning","localesSuffix","map","localeRow"],"mappings":"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"}