{"version":3,"sources":["../../src/upsertRow/index.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { TypeWithID } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport { ValidationError } from 'payload'\n\nimport type { BlockRowToInsert } from '../transform/write/types.js'\nimport type { Args } from './types.js'\n\nimport { buildFindManyArgs } from '../find/buildFindManyArgs.js'\nimport { transform } from '../transform/read/index.js'\nimport { transformForWrite } from '../transform/write/index.js'\nimport { deleteExistingArrayRows } from './deleteExistingArrayRows.js'\nimport { deleteExistingRowsByPath } from './deleteExistingRowsByPath.js'\nimport { insertArrays } from './insertArrays.js'\n\nexport const upsertRow = async <T extends Record<string, unknown> | TypeWithID>({\n  id,\n  adapter,\n  data,\n  db,\n  fields,\n  ignoreResult,\n  operation,\n  path = '',\n  req,\n  tableName,\n  upsertTarget,\n  where,\n}: Args): Promise<T> => {\n  // Split out the incoming data into the corresponding:\n  // base row, locales, relationships, blocks, and arrays\n  const rowToInsert = transformForWrite({\n    adapter,\n    data,\n    fields,\n    path,\n    tableName,\n  })\n\n  // First, we insert the main row\n  let insertedRow: Record<string, unknown>\n\n  try {\n    if (operation === 'update') {\n      const target = upsertTarget || adapter.tables[tableName].id\n\n      if (id) {\n        rowToInsert.row.id = id\n        ;[insertedRow] = await db\n          .insert(adapter.tables[tableName])\n          .values(rowToInsert.row)\n          .onConflictDoUpdate({ set: rowToInsert.row, target })\n          .returning()\n      } else {\n        ;[insertedRow] = await db\n          .insert(adapter.tables[tableName])\n          .values(rowToInsert.row)\n          .onConflictDoUpdate({ set: rowToInsert.row, target, where })\n          .returning()\n      }\n    } else {\n      ;[insertedRow] = await db\n        .insert(adapter.tables[tableName])\n        .values(rowToInsert.row)\n        .returning()\n    }\n\n    const localesToInsert: Record<string, unknown>[] = []\n    const relationsToInsert: Record<string, unknown>[] = []\n    const textsToInsert: Record<string, unknown>[] = []\n    const numbersToInsert: Record<string, unknown>[] = []\n    const blocksToInsert: { [blockType: string]: BlockRowToInsert[] } = {}\n    const selectsToInsert: { [selectTableName: string]: Record<string, unknown>[] } = {}\n\n    // If there are locale rows with data, add the parent and locale to each\n    if (Object.keys(rowToInsert.locales).length > 0) {\n      Object.entries(rowToInsert.locales).forEach(([locale, localeRow]) => {\n        localeRow._parentID = insertedRow.id\n        localeRow._locale = locale\n        localesToInsert.push(localeRow)\n      })\n    }\n\n    // If there are relationships, add parent to each\n    if (rowToInsert.relationships.length > 0) {\n      rowToInsert.relationships.forEach((relation) => {\n        relation.parent = insertedRow.id\n        relationsToInsert.push(relation)\n      })\n    }\n\n    // If there are texts, add parent to each\n    if (rowToInsert.texts.length > 0) {\n      rowToInsert.texts.forEach((textRow) => {\n        textRow.parent = insertedRow.id\n        textsToInsert.push(textRow)\n      })\n    }\n\n    // If there are numbers, add parent to each\n    if (rowToInsert.numbers.length > 0) {\n      rowToInsert.numbers.forEach((numberRow) => {\n        numberRow.parent = insertedRow.id\n        numbersToInsert.push(numberRow)\n      })\n    }\n\n    // If there are selects, add parent to each, and then\n    // store by table name and rows\n    if (Object.keys(rowToInsert.selects).length > 0) {\n      Object.entries(rowToInsert.selects).forEach(([selectTableName, selectRows]) => {\n        selectRows.forEach((row) => {\n          if (typeof row.parent === 'undefined') {\n            row.parent = insertedRow.id\n          }\n          if (!selectsToInsert[selectTableName]) selectsToInsert[selectTableName] = []\n          selectsToInsert[selectTableName].push(row)\n        })\n      })\n    }\n\n    // If there are blocks, add parent to each, and then\n    // store by table name and rows\n    Object.keys(rowToInsert.blocks).forEach((blockName) => {\n      rowToInsert.blocks[blockName].forEach((blockRow) => {\n        blockRow.row._parentID = insertedRow.id\n        if (!blocksToInsert[blockName]) blocksToInsert[blockName] = []\n        if (blockRow.row.uuid) {\n          delete blockRow.row.uuid\n        }\n        blocksToInsert[blockName].push(blockRow)\n      })\n    })\n\n    // //////////////////////////////////\n    // INSERT LOCALES\n    // //////////////////////////////////\n\n    if (localesToInsert.length > 0) {\n      const localeTable = adapter.tables[`${tableName}${adapter.localesSuffix}`]\n\n      if (operation === 'update') {\n        await db.delete(localeTable).where(eq(localeTable._parentID, insertedRow.id))\n      }\n\n      await db.insert(localeTable).values(localesToInsert)\n    }\n\n    // //////////////////////////////////\n    // INSERT RELATIONSHIPS\n    // //////////////////////////////////\n\n    const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...relationsToInsert, ...rowToInsert.relationshipsToDelete],\n        tableName: relationshipsTableName,\n      })\n    }\n\n    if (relationsToInsert.length > 0) {\n      await db.insert(adapter.tables[relationshipsTableName]).values(relationsToInsert)\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany TEXTS\n    // //////////////////////////////////\n\n    const textsTableName = `${tableName}_texts`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: textsToInsert,\n        tableName: textsTableName,\n      })\n    }\n\n    if (textsToInsert.length > 0) {\n      await db.insert(adapter.tables[textsTableName]).values(textsToInsert).returning()\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany NUMBERS\n    // //////////////////////////////////\n\n    const numbersTableName = `${tableName}_numbers`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: numbersToInsert,\n        tableName: numbersTableName,\n      })\n    }\n\n    if (numbersToInsert.length > 0) {\n      await db.insert(adapter.tables[numbersTableName]).values(numbersToInsert).returning()\n    }\n\n    // //////////////////////////////////\n    // INSERT BLOCKS\n    // //////////////////////////////////\n\n    const insertedBlockRows: Record<string, Record<string, unknown>[]> = {}\n\n    if (operation === 'update') {\n      for (const blockName of rowToInsert.blocksToDelete) {\n        const blockTableName = adapter.tableNameMap.get(`${tableName}_blocks_${blockName}`)\n        const blockTable = adapter.tables[blockTableName]\n        await db.delete(blockTable).where(eq(blockTable._parentID, insertedRow.id))\n      }\n    }\n\n    for (const [blockName, blockRows] of Object.entries(blocksToInsert)) {\n      const blockTableName = adapter.tableNameMap.get(`${tableName}_blocks_${blockName}`)\n      insertedBlockRows[blockName] = await db\n        .insert(adapter.tables[blockTableName])\n        .values(blockRows.map(({ row }) => row))\n        .returning()\n\n      insertedBlockRows[blockName].forEach((row, i) => {\n        blockRows[i].row = row\n      })\n\n      const blockLocaleIndexMap: number[] = []\n\n      const blockLocaleRowsToInsert = blockRows.reduce((acc, blockRow, i) => {\n        if (Object.entries(blockRow.locales).length > 0) {\n          Object.entries(blockRow.locales).forEach(([blockLocale, blockLocaleData]) => {\n            if (Object.keys(blockLocaleData).length > 0) {\n              blockLocaleData._parentID = blockRow.row.id\n              blockLocaleData._locale = blockLocale\n              acc.push(blockLocaleData)\n              blockLocaleIndexMap.push(i)\n            }\n          })\n        }\n\n        return acc\n      }, [])\n\n      if (blockLocaleRowsToInsert.length > 0) {\n        await db\n          .insert(adapter.tables[`${blockTableName}${adapter.localesSuffix}`])\n          .values(blockLocaleRowsToInsert)\n          .returning()\n      }\n\n      await insertArrays({\n        adapter,\n        arrays: blockRows.map(({ arrays }) => arrays),\n        db,\n        parentRows: insertedBlockRows[blockName],\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT ARRAYS RECURSIVELY\n    // //////////////////////////////////\n\n    if (operation === 'update') {\n      for (const arrayTableName of Object.keys(rowToInsert.arrays)) {\n        await deleteExistingArrayRows({\n          adapter,\n          db,\n          parentID: insertedRow.id,\n          tableName: arrayTableName,\n        })\n      }\n    }\n\n    await insertArrays({\n      adapter,\n      arrays: [rowToInsert.arrays],\n      db,\n      parentRows: [insertedRow],\n    })\n\n    // //////////////////////////////////\n    // INSERT hasMany SELECTS\n    // //////////////////////////////////\n\n    for (const [selectTableName, tableRows] of Object.entries(selectsToInsert)) {\n      const selectTable = adapter.tables[selectTableName]\n      if (operation === 'update') {\n        await db.delete(selectTable).where(eq(selectTable.parent, insertedRow.id))\n      }\n      await db.insert(selectTable).values(tableRows).returning()\n    }\n\n    // //////////////////////////////////\n    // Error Handling\n    // //////////////////////////////////\n  } catch (error) {\n    throw error.code === '23505'\n      ? new ValidationError(\n          {\n            errors: [\n              {\n                field: adapter.fieldConstraints[tableName][error.constraint],\n                message: req.t('error:valueMustBeUnique'),\n              },\n            ],\n          },\n          req.t,\n        )\n      : error\n  }\n\n  if (ignoreResult) return data as T\n\n  // //////////////////////////////////\n  // RETRIEVE NEWLY UPDATED ROW\n  // //////////////////////////////////\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    tableName,\n  })\n\n  findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n  const doc = await db.query[tableName].findFirst(findManyArgs)\n\n  // //////////////////////////////////\n  // TRANSFORM DATA\n  // //////////////////////////////////\n\n  const result = transform<T>({\n    adapter,\n    config: adapter.payload.config,\n    data: doc,\n    fields,\n  })\n\n  return result\n}\n"],"names":["eq","ValidationError","buildFindManyArgs","transform","transformForWrite","deleteExistingArrayRows","deleteExistingRowsByPath","insertArrays","upsertRow","id","adapter","data","db","fields","ignoreResult","operation","path","req","tableName","upsertTarget","where","rowToInsert","insertedRow","target","tables","row","insert","values","onConflictDoUpdate","set","returning","localesToInsert","relationsToInsert","textsToInsert","numbersToInsert","blocksToInsert","selectsToInsert","Object","keys","locales","length","entries","forEach","locale","localeRow","_parentID","_locale","push","relationships","relation","parent","texts","textRow","numbers","numberRow","selects","selectTableName","selectRows","blocks","blockName","blockRow","uuid","localeTable","localesSuffix","delete","relationshipsTableName","relationshipsSuffix","localeColumnName","parentColumnName","parentID","pathColumnName","rows","relationshipsToDelete","textsTableName","numbersTableName","insertedBlockRows","blocksToDelete","blockTableName","tableNameMap","get","blockTable","blockRows","map","i","blockLocaleIndexMap","blockLocaleRowsToInsert","reduce","acc","blockLocale","blockLocaleData","arrays","parentRows","arrayTableName","tableRows","selectTable","error","code","errors","field","fieldConstraints","constraint","message","t","findManyArgs","depth","doc","query","findFirst","result","config","payload"],"mappings":"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"}